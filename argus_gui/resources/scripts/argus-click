#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import absolute_import
import yaml
import os
import sys
import cv2

# Windows OpenGL compatibility settings - MUST be set before pyglet import
if sys.platform.startswith('win'):
    # Force software rendering if hardware acceleration is problematic
    os.environ['PYGLET_GL_DISABLE_MULTISAMPLING'] = '1'
    os.environ['PYGLET_GL_FALLBACK'] = '1'
    os.environ['PYGLET_SHADOW_WINDOW'] = '0'
    # Force OpenGL software rendering as fallback
    os.environ['MESA_GL_VERSION_OVERRIDE'] = '3.3'
    # Disable advanced OpenGL features that might not be supported
    os.environ['PYGLET_GL_DISABLE_WGL'] = '1'

import pyglet
from pyglet.gl import Config
from pyglet import shapes
from pyglet.window import key, mouse
from pyglet.graphics import *
from pyglet.image import ImageData

from argus_gui import ArgusColors, FrameFinder, ClickerProject
from argus_gui.tools import *
import pandas
import argus.ocam
from PySide6.QtCore import Qt
# Delay pyqtgraph.opengl import to avoid OpenGL conflicts
# import pyqtgraph.opengl as pyqt_gl  # Will be imported later when needed
from scipy.sparse import csc_matrix, lil_matrix
import time
import numpy as np
import copy
import threading

from PySide6 import QtWidgets, QtCore

colors = ArgusColors()
colors = colors.getPygletColors()

colors = [(u[0], u[1], u[2], 180) for u in colors]

# Define the colors we will use in RGBA format
CAROLINA_BLUE = (153, 186, 221, 255)  # Go Tar Heels!
MARKER_COLOR = (255, 105, 180, 200)

# Global OpenGL context lock for thread safety on Windows
# This prevents context conflicts when multiple windows try to access OpenGL simultaneously
gl_context_lock = threading.RLock() if sys.platform.startswith('win') else None


class GoToPopupWindow(QtWidgets.QDialog):
    """Popup window for skipping to specified frame
    """
    def __init__(self, number_of_frames, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Enter frame number")
        layout = QtWidgets.QVBoxLayout(self)
        self.go_to_frame = QtWidgets.QSpinBox()
        self.go_to_frame.setValue(current_frame)
        self.go_to_frame.setMaximum(number_of_frames)
        layout.addWidget(self.go_to_frame)
        self.label = QtWidgets.QLabel(f'out of {number_of_frames}')
        layout.addWidget(self.label)
        button = QtWidgets.QPushButton("Ok")
        button.clicked.connect(self.accept)
        layout.addWidget(button)
    
    def showEvent(self, event):
        super().showEvent(event)
        self.go_to_frame.setFocus()
        self.go_to_frame.selectAll()

class YesNoPopup(QtWidgets.QWidget):
    def __init__(self, question):
        super().__init__()

        reply = QtWidgets.QMessageBox.question(self, "Question", question, QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)

        if reply == QtWidgets.QMessageBox.Yes:
            self.reply = "Yes"
        else:
            self.reply = "No"

class OpenFilePopup(QtWidgets.QWidget):
    def __init__(self, win_title, init, filt):
        super().__init__()
        self.filename, _ = QtWidgets.QFileDialog.getOpenFileName(self, caption = win_title, dir = init, filter = filt)

class SaveFilePopup(QtWidgets.QWidget):
    def __init__(self, win_title, init, filt):
        super().__init__()
        # Show the save file dialog
        options = QtWidgets.QFileDialog.Options()
        # options |= QtWidgets.QFileDialog.DontUseNativeDialog
        self.filename, _ = QtWidgets.QFileDialog.getSaveFileName(self, caption=win_title, dir = init, filter = filt, options=options)

def clean_filename_for_prefix(filename):
    """
    Remove file extension from filename to use as a clean prefix.
    This ensures consistent behavior across platforms where Windows may force 
    users to add extensions while Mac does not.
    
    Args:
        filename (str): The filename from the file dialog
        
    Returns:
        str: The filename without extension, suitable for use as a prefix
    """
    if not filename:
        return filename
    # Use os.path.splitext to remove the extension
    base_name, ext = os.path.splitext(filename)
    return base_name

def load_camera(filename):
    global camera_profile
    global camera_filename
    if filename:
        camera_profile = np.loadtxt(filename)
        # Pinhole distortion
        if camera_profile.shape[1] == 12:
            # Format the camera profile to how SBA expects it
            # i.e. take out camera number column, image width and height, then add in skew.
            camera_profile = np.delete(camera_profile, [0, 2, 3, 6], axis=1)

        # CMei's omnidirectional distortion model
        # Citation: http://www.robots.ox.ac.uk/~cmei/articles/single_viewpoint_calib_mei_07.pdf
        elif camera_profile.shape[1] == 13:
            new_list = []
            camera_number_checker = 1
            for profile in camera_profile:
                try:
                    if profile[0] != camera_number_checker:
                        QtWidgets.QMessageBox.warning(None,
                            "Error",
                            "Camera indexes are either not correctly formatted or non-existence"
                        )
                    # Remove the camera index
                    profile = np.delete(profile, [0])

                    # build the list of CMeiUndistorter objects (can't replace them in place as the original
                    # array is numpy and won't accept varying type
                    new_list.append(argus.ocam.CMeiUndistorter(argus.ocam.ocam_model.from_array(profile)))
                    camera_number_checker += 1
                # TODO: Better Error Handling
                except Exception as e:
                    print(e)
                    QtWidgets.QMessageBox.warning(None,
                        "Error",
                        "Could not load Camera profile!"
                    )
                    return
            camera_profile = new_list


        # Scaramuzza's omnidirectional distortion model
        # Citation: http://rpg.ifi.uzh.ch/docs/omnidirectional_camera.pdf
        else:
            new_list = []
            camera_number_checker = 1 
            for profile in camera_profile:
                try:
                    if profile[0] != camera_number_checker:
                        QtWidgets.QMessageBox.warning(None,
                            "Error",
                            "Camera indexes are either not correctly formatted or non-existent"
                        )
                        return
                    # Remove the camera index
                    profile = np.delete(profile, [0])

                    # build the list of PointUndistorter objects (can't replace them in place as the original
                    # array is numpy and won't accept varying type
                    new_list.append(argus.ocam.PointUndistorter(argus.ocam.ocam_model.from_array(profile)))
                    camera_number_checker += 1
                # TODO: Better Error Handling
                except Exception as e:
                    print(e)
                    QtWidgets.QMessageBox.warning(None,
                        "Error",
                        "Could not load Camera profile!"
                    )
                    return
            camera_profile = new_list
        camera_filename = filename

class OptionsPopupWindow(QtWidgets.QDialog):
    """# popup window for the options dialog
    """

    def __init__(self, sync, auto, track_list, track, disp, bstrap, o_sparse, rgb, radius, thickness, parent=None):

        super().__init__(parent)
        self.setWindowTitle("Options")

        self.o_sparse = o_sparse
        self.rgb = rgb
        self.track_list = track_list

        self.cam_entry = QtWidgets.QLineEdit()
        self.lc = QtWidgets.QPushButton('Load camera profile')
        self.lc.clicked.connect(self.load_camera)
        
        self.dlt = QtWidgets.QLineEdit()
        self.ld = QtWidgets.QPushButton('Load DLT coefficients')
        self.ld.clicked.connect(self.load_DLT)

        self.tracks = QtWidgets.QComboBox()
        self.tracks.addItems(track_list)
        self.track = track
        self.tracks.setCurrentText(self.track)

        self.add_button = QtWidgets.QPushButton("Add a new track")
        self.add_button.clicked.connect(self.newTrack)

        self.disp = QtWidgets.QCheckBox("Display all tracks")
        self.disp.setChecked(disp)

        self.sync = QtWidgets.QCheckBox("Keep all videos in same frame")
        self.sync.setChecked(sync)

        self.auto = QtWidgets.QCheckBox("Automatically advance frames")
        self.auto.setChecked(auto)

        self.radius_label = QtWidgets.QLabel("Marker radius")
        self.radius = QtWidgets.QSpinBox()
        self.radius.setValue(radius)
        self.thickness_label = QtWidgets.QLabel("Track line thickness")
        self.thickness = QtWidgets.QSpinBox()
        self.thickness.setValue(thickness)

        self.bstrap = QtWidgets.QCheckBox("Save 95% CIs, spline filtering weights,\nand error tolerance")
        self.bstrap.setChecked(bstrap)

        self.formatlabel = QtWidgets.QLabel("Save format: ")
        self.formatbox = QtWidgets.QComboBox()
        self.formatbox.addItems(["Dense .csv", "Sparse .tsv"])
        self.formatbox.currentIndexChanged.connect(self.sparse_toggle)
        if self.o_sparse:
            self.formatbox.setCurrentText("Sparse .tsv")
        else:
            self.formatbox.setCurrentText("Dense .csv")

        self.colorlabel = QtWidgets.QLabel("Display: ")
        self.colorbox = QtWidgets.QComboBox()
        self.colorbox.addItems(['RGB color', 'grayscale'])
        self.colorbox.currentIndexChanged.connect(self.color_toggle)
        if self.rgb:
            self.colorbox.setCurrentText('RGB color')
        else:
            self.colorbox.setCurrentText('grayscale')

        self.savelabel = QtWidgets.QLabel("Save location/tag: ")
        self.fnam = QtWidgets.QLineEdit()
        self.save_button = QtWidgets.QPushButton('Specify')
        self.save_button.clicked.connect(self.save_as)

        self.dlc_button = QtWidgets.QPushButton("Load DeepLabCut Data")
        self.dlc_button.clicked.connect(self.load_dlc_data)

        self.okbutton = QtWidgets.QPushButton("Ok")
        self.okbutton.clicked.connect(self.accept)
        
        # set values to globals if they are already set
        self.cam_entry.setText(camera_filename)
        self.dlt.setText(dlt_filename)
        self.fnam.setText(global_filename)
        
        # GUI structure
        genlabel = QtWidgets.QLabel("General Settings")
        displabel = QtWidgets.QLabel("Display options")
        outlabel = QtWidgets.QLabel("Save Settings")
        divider1 = QtWidgets.QFrame()
        divider1.setFrameShape(QtWidgets.QFrame.HLine)
        divider1.setFrameShadow(QtWidgets.QFrame.Sunken)
        divider2 = QtWidgets.QFrame()
        divider2.setFrameShape(QtWidgets.QFrame.HLine)
        divider2.setFrameShadow(QtWidgets.QFrame.Sunken)        

        layout = QtWidgets.QGridLayout(self)
        layout.addWidget(genlabel, 0, 0)
        layout.addWidget(self.cam_entry, 1, 0, 1, 2)
        layout.addWidget(self.lc, 1, 2)
        layout.addWidget(self.dlt, 2, 0, 1, 2)
        layout.addWidget(self.ld, 2, 2)
        layout.addWidget(self.tracks, 3, 0)
        layout.addWidget(self.add_button, 3, 1)

        layout.addWidget(divider1, 4, 0, 1, 3)
        layout.addWidget(displabel, 5, 0, 1, 3)
        layout.addWidget(self.disp, 6, 0)
        layout.addWidget(self.auto, 7, 0)
        layout.addWidget(self.sync, 8, 0)
        layout.addWidget(self.radius_label, 8, 1)
        layout.addWidget(self.radius, 8, 2)
        layout.addWidget(self.colorlabel, 9, 0)
        layout.addWidget(self.colorbox, 9, 0, QtCore.Qt.AlignRight)
        layout.addWidget(self.thickness_label, 9, 1)
        layout.addWidget(self.thickness, 9, 2)
        
        layout.addWidget(divider2, 10, 0, 1, 3)
        layout.addWidget(outlabel, 11, 0, 1, 3)
        layout.addWidget(self.bstrap, 12, 0)
        layout.addWidget(self.formatlabel, 13, 0)
        layout.addWidget(self.formatbox, 13, 0, QtCore.Qt.AlignRight)
        layout.addWidget(self.savelabel, 14, 0)
        layout.addWidget(self.fnam, 15, 0, 1, 2)
        layout.addWidget(self.save_button, 15, 2)
        layout.addWidget(self.dlc_button, 16, 0, 1, 3)
        layout.addWidget(self.okbutton, 17, 2)

    # close with Return key
    def keyPressEvent(self, event):
        if event.key() == QtCore.Qt.Key_Return:
            self.accept()

    # popup window for inputting track name
    def newTrack(self):
        track_name_window = newTrackPopup(self)
        if track_name_window.exec() == QtWidgets.QDialog.Accepted:
            new_name = track_name_window.line_edit.text()

        # check to make sure the track name is not empty and does not already exist
        if new_name != '' and new_name not in self.track_list:
            self.track_list.append(new_name)
            self.tracks.addItem(new_name)
            self.tracks.setCurrentText(new_name)

        else:
            QtWidgets.QMessageBox.warning(None,
                "Error",
                "Track names must be unique and non-empty"
            )

    def load_camera(self):
        filename, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Choose camera profile", filter="Text files (*.txt)")
        try:
            if filename:
                load_camera(filename)
                self.cam_entry.setText(filename)
        except:
            QtWidgets.QMessageBox.warning(None,
                "Error",
                "Could not load Camera profile!"
            )

    def load_DLT(self):
        global DLTCoefficients
        global dlt_filename
        filename, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Choose DLT coefficients file", filter="CSV files (*.csv)")

        if filename:
            try:
                DLTCoefficients = np.loadtxt(filename, delimiter=',')
                DLTCoefficients = DLTCoefficients.T
                self.dlt.setText(filename)
                dlt_filename = filename
            # TODO: Better Exception Handling
            except:
                QtWidgets.QMessageBox.warning(None,
                    "Error",
                    "Could not load DLT coefficients!"
                )
            
    def sparse_toggle(self):
        if self.formatbox.currentText() == "Sparse .tsv":
            self.o_sparse = True
        elif self.formatbox.currentText() == "Dense .csv":
            self.o_sparse = False

    def color_toggle(self):
        if self.colorbox.currentText() == "RGB color":
            self.rgb == True
        elif self.colorbox.currentText() == "grayscale":
            self.rgb == False

    def save_as(self):
        global global_filename
        filename, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Select location and enter file name prefix")
        if filename != '':
            self.fnam.setText(filename)
            global_filename = filename

    def load_dlc_data(self):
        """
        Load DeepLabCut h5 files for each open video window.
        Prompts user to select one h5 file per open video window.
        """
        # Get list of open video windows
        video_windows = [window for window in pyglet.app.windows if isinstance(window, ClickerWindow)]
        
        if not video_windows:
            QtWidgets.QMessageBox.warning(None,
                "Error",
                "No video windows are currently open. Please open video files first."
            )
            return
        
        # Track h5 file paths for each window
        h5_file_paths = []
        
        # Sort windows by camera number for consistent ordering
        video_windows.sort(key=lambda w: w.actual_camera_number)
        
        for window in video_windows:
            # Prompt user to select h5 file for this camera
            movie_name = window.movie.split('/')[-1] if window.movie else f"Camera {window.actual_camera_number}"
            
            filename, _ = QtWidgets.QFileDialog.getOpenFileName(
                self, 
                f"Select DeepLabCut h5 file for {movie_name} (Camera {window.actual_camera_number})",
                filter="HDF5 files (*.h5 *.hdf5)"
            )
            
            if not filename:
                # User cancelled, don't continue
                QtWidgets.QMessageBox.information(None,
                    "Cancelled",
                    "DeepLabCut data loading cancelled."
                )
                return
            
            h5_file_paths.append(filename)
        
        # All files selected, now call load_dlc function
        # For now, we'll just pass the first file since load_dlc function is incomplete
        # TODO: Modify load_dlc to handle multiple files when it's fully implemented
        try:
            load_dlc(h5_file_paths, offsets = None, like=0.9, flipy=True)
            QtWidgets.QMessageBox.information(None,
                "Success",
                f"Successfully loaded DeepLabCut data from {len(h5_file_paths)} file(s)."
            )
        except Exception as e:
            QtWidgets.QMessageBox.warning(None,
                "Error",
                f"Failed to load DeepLabCut data: {str(e)}"
            )

class newTrackPopup(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Name the new track")
        layout = QtWidgets.QVBoxLayout(self)
        self.line_edit = QtWidgets.QLineEdit()
        layout.addWidget(self.line_edit)
        button = QtWidgets.QPushButton("Ok")
        button.clicked.connect(self.accept)
        layout.addWidget(button)

def draw_circle(coordinates, radius, color = (255, 255, 255, 255), batch = None):
    # coordinates should be passed in as a tupple of (x1, y1)
    x = coordinates[0]
    y = coordinates[1]
    return shapes.Circle(
                x, y, radius,
                color = color,
                batch = batch
    )
    
def draw_line(pt1, pt2, color=(255, 255, 255, 255), width = None, batch=None):
    global thickness
    if width == None:
        width = thickness
    # pt1 and pt2 are tuples or arrays like (x, y) for the two ends of the line
    (x1, y1) = pt1
    (x2, y2) = pt2
    
    # Pyglet 2.1+ removed the width parameter for Line
    # Create line without width parameter for compatibility
    # But there are other issues with window size that need to be fixed still - so install is forced to pyglet < 2.1
    try:
        # Try with width parameter (Pyglet 2.0.x)
        return shapes.Line(
            x1, y1, x2, y2,
            width = width,
            color = color,
            batch = batch
        )
    except TypeError:
        # Fallback without width parameter (Pyglet 2.1+)
        return shapes.Line(
            x1, y1, x2, y2,
            color = color,
            batch = batch
        )


# global variables for options and current track
# all windows pay attention to and modify these
# set to defaults
track_list_global = ['Track 1']
current_track_global = 'Track 1'
auto_advance = True
sync = True
displaying_all_tracks = False
current_frame = 1
common = dict()
load_data_global = None
no_cameras_global = 0
DLTCoefficients = None
camera_profile = None
bstrap = False
busy = False
outputSparse = False
global_filename = ''
rgb = True
vw = 15
vh = 15
# vf = 30
radius = 3
thickness = 3

dlt_filename = ''
camera_filename = ''

# Zooming constants
ZOOM_IN_FACTOR = 1.2
ZOOM_OUT_FACTOR = 1 / ZOOM_IN_FACTOR


# called once to load the CSV into a numpy array a populate the track list, expects a header
def load_csv(csv):
    global load_data_global
    global no_cameras_global
    global track_list_global
    global current_track_global

    # sys.stdout.flush()

    # try:
    track_csv = open(csv)
    header = track_csv.readline()
    new_tracks = []
    header = header.split(',')
    for st in header:
        if st.rsplit('_', 3)[0] not in new_tracks:
            new_tracks.append(st.rsplit('_', 3)[0])

    track_csv.close()

    track_list_global = new_tracks
    current_track_global = track_list_global[0]

    # sys.stdout.flush()
    load_data_global = np.array(pandas.read_csv(csv, index_col=False).values, dtype=np.float16)
    load_data_global[np.isnan(load_data_global)] = 0
    load_data_global = csc_matrix(load_data_global, dtype = np.float32)

    no_cameras_global = len([u for u in pyglet.app.windows if type(u) != GhostWindow])

    # TODO: Better Exception Handling
    # except:
    #     QtWidgets.QMessageBox.warning(None,
    #         "Error",
    #         "Could not load CSV! Make sure it is formatted according to the documentation."
    #     )
    # sys.stdout.flush()

def load_dlc(h5_files, like=0.9, flipy=True):
    """
    Load DeepLabCut data from h5 files for multiple cameras.
    
    Args:
        h5_files: List of h5 file paths, one for each camera window
    """
    global load_data_global
    global no_cameras_global
    global track_list_global
    global current_track_global

    # load dlc file for each camera
    # number of cameras is determined by how many windows are open
    video_windows = [window for window in pyglet.app.windows if isinstance(window, ClickerWindow)]
    no_cameras_global = len(video_windows)
    offsets = [window.offset for window in video_windows]
    if len(h5_files) != no_cameras_global:
        raise ValueError(f"Number of h5 files ({len(h5_files)}) does not match number of open video windows ({no_cameras_global})")
    
    # For now, just implement a basic structure that loads the first file
    # TODO: Complete implementation to handle multiple cameras and build data in DLT format
    
    # Get track names from first file to ensure they match across all cameras
    # If maDLC, ask user if single animal at a time or all animals at once
    # If all animals, make track names like 'indiv1_track1_cam_1_x, indiv1_track1_cam_1_y' etc.
    # Track names go in track_list_global
    # Build data in DLT format (2xNxt cols, N = number of cameras, t= tracks)
    # Loop through cameras and combine data
    # Data is saved as load_data_global (no column names needed just same order as track names)
    # NaNs converted to 0, converted to csc_matrix

    try:
        # Load the first file to get structure - expects a multiindex header
        # For single animal DLC projects, this is (scorer, body part, coords (x, y, likelihood))
        # For multi-animal DLC projects, this is (scorer, animal, body part, coords (x, y, likelihood))
        alldata = {}
        numframes = []
        scorers= []
        madlc = False
        for c in range(no_cameras_global):
            # Load each h5 file
            if not os.path.exists(h5_files[c]):
                raise FileNotFoundError(f"DeepLabCut h5 file not found: {h5_files[c]}")
            
            # Read the h5 file
            print(f"Loading DLC data from {h5_files[c]}")
            camdata = pandas.read_hdf(h5_files[c], key='df_with_missing')
            scorers.append(camdata.columns.get_level_values('scorer')[0])
            # if this is the first file in the list, determine several variables
            if c == 0:
                tracks = camdata.columns.get_level_values('bodypart').unique().tolist()
                #determine if multianimal dlc based on number of levels in the multiindex
                if isinstance(camdata.columns, pandas.MultiIndex):
                    if len(camdata.columns.levels) == 3:
                        # Single animal DLC project
                        print("Detected single animal DLC project")
                        madlc = False
                    elif len(camdata.columns.levels) == 4:
                        # Multi-animal DLC project
                        print("Detected multi-animal DLC project")
                        madlc = True
                    else:
                        raise ValueError("Unexpected number of levels in DLC multiindex columns")
                else:
                    raise ValueError("DLC data does not have expected multiindex format")
            
            if madlc:
                alldata[c] = {}
                individuals = camdata.columns.get_level_values('animal').unique().tolist()
                for ind in individuals:
                    for track in set(tracks):
                        # set coords with low likelihood values to NaN
                        camdata.loc[camdata[scorers[c]][ind][track]['likelihood'] <= like, (scorers[c], ind, track, ['x', 'y'])] = np.nan
                    alldata[c][ind]=camdata[scorers[c]][ind]
            else:
                for track in set(tracks):
                    camdata.loc[camdata[scorers[c]][track]['likelihood'] <= like, (scorers[c], track, ['x', 'y'])] = np.nan
                alldata[c] = camdata[scorers[c]]
            numframes.append(max(camdata.index.values) + 1)  # DLC indices are 0-based, so add 1 for frame count

    except:
        raise Exception("Could not load DLC data. Make sure files are formatted according to DLC documentation.")
    
    # initialize the massive array full of nans (with more than enough rows)
    blankarr = np.empty((max(numframes) - min(offsets), len(tracks) * 2 * no_cameras_global)) + np.nan
    xcols = range(0, len(tracks) * 2 * no_cameras_global, 2)
    ycols = range(1, len(tracks) * 2 * no_cameras_global, 2)
    # outdata is a dict with first key = indiv (0 if not multianimal)
    outdata = {}
    if madlc:
        for ind in individuals:
            outdata[ind]=blankarr.copy()
    else:
        outdata[0] = blankarr.copy()
    # loopthrough each camera's data and assign to the proper row
    # get list of camera windows
    video_windows = [window for window in pyglet.app.windows if isinstance(window, ClickerWindow)]
    for c, camdata in alldata.items():
        # need to check for "height", and flip the y-coordinates (origin is lower left in Argus and DLTdv 1-7, upper left in openCV, DLC, DLTdv8)
        # height is saved in self.frameFinder.oh
        height = video_windows[c].frameFinder.oh
        width = video_windows[c].frameFinder.ow
        # make lists of rows, of matching length, that account for offsets (out = in - offset)
        outrows = list(range(max([0, 0 - offsets[c]]), min([numframes[c], numframes[c] - offsets[c]]), 1))
        inrows = list(range(max([0, 0 + offsets[c]]), min([numframes[c], numframes[c] + offsets[c]]), 1))
        iter = 3
        if madlc:
            for ind in individuals:
                for i in range(len(tracks)):
                    incol = i * iter
                    outcol = (i * 2 * no_cameras_global) + (2 * c)
                    if flipy:
                        outdata[ind][outrows, outcol] = camdata[ind].iloc[inrows, incol]
                        outdata[ind][outrows, outcol+1] = height - camdata[ind].iloc[inrows,incol+1]
                    else:
                        outdata[ind][outrows, outcol:outcol+2] = camdata[ind].iloc[inrows, incol:incol+2]
                    # set out of range values to nan
                    outdata[ind][outdata[ind] <= 0] = np.nan

                    for xc in xcols:
                        foo = outdata[ind][:, xc]
                        foo[foo >= width] = np.nan
                        outdata[ind][:, xc] = foo

                    for yc in ycols:
                        foo = outdata[ind][:, yc]
                        foo[foo >= height] = np.nan
                        outdata[ind][:, yc] = foo

        else:
            for i in range(len(tracks)):
                incol = i * iter
                outcol = (i * 2 * no_cameras_global) + (2 * c)
                if flipy:
                    outdata[0][outrows, outcol] = camdata.iloc[inrows, incol]
                    outdata[0][outrows, outcol+1] = height - camdata.iloc[inrows, incol+1]
                else:
                    outdata[0][outrows, outcol:outcol+2] = camdata.iloc[inrows, incol:incol+2]

    
        
        # TODO: Complete the implementation to:
        # 1. Parse the multiindex header to extract body parts/animals
        # 2. Load data from all h5 files 
        # 3. Combine into the expected format for argus (matching existing CSV format)
        # 4. Handle likelihood thresholds
        # 5. Convert to sparse matrix format
        
        # For now, create placeholder structure
        print(f"DLC data loading initiated for {len(h5_files)} files")
        print(f"First file structure: {dlc_data.columns}")
        print("TODO: Complete DLC data parsing and integration")
        
        # Placeholder - set up basic track structure
        track_list_global = ['Track 1']  # TODO: Extract from DLC data
        current_track_global = track_list_global[0]
        
        # TODO: Build proper load_data_global matrix from all camera files
        # For now, create empty structure
        load_data_global = csc_matrix((100, 2 * no_cameras_global))  # Placeholder
        
        print("DLC loading structure created - implementation incomplete")
        
    except Exception as e:
        raise Exception(f"Could not load DLC data: {str(e)}. Make sure files are formatted according to DLC documentation.")

# for sparse data files as TSVs
def load_tsv(tsv):
    global load_data_global
    global no_cameras_global
    global track_list_global
    global current_track_global

    try:
        # load the file, expects a header
        csv_data = pandas.read_csv(tsv, index_col=False, sep='\t', skiprows=1)
        # read into numpy array
        load_data_global = np.zeros((int(list(csv_data.keys())[0]), int(list(csv_data.keys())[1])), dtype=np.float16)
        csv_data = csv_data.values
        for k in range(len(csv_data)):
            load_data_global[int(csv_data[k, 0]) - 1, int(csv_data[k, 1]) - 1] = csv_data[k, 2]

        # convert to compressed sparse matrix form
        load_data_global = csc_matrix(load_data_global)

        no_cameras_global = len([u for u in pyglet.app.windows if type(u) != GhostWindow])

        track_list_global = list()
        for k in range(int(load_data_global.shape[1] / (2 * no_cameras_global))):
            track_list_global.append('Track ' + str(k + 1))

        current_track_global = track_list_global[0]
    except:
        QtWidgets.QMessageBox.warning(None,
            "Error",
            "Could not load TSV! Make sure it is formatted according to the documentation."
        )


# TODO: Implement abstract classes

# main class which displays the movie's individual frames and allows users to mark points
class ClickerWindow(pyglet.window.Window):
    def __init__(self, movie, offsets, actual_camera_number, end, factor, last=False):
        
        self.initialized = False #flag to control running on_resize function
        self.actual_camera_number = actual_camera_number
        self.original_index = actual_camera_number - 1

        # Function for converting openCV images to pyglt compatible frames
        self.frameFinder = FrameFinder(movie, factor=factor, offset=offsets[self.original_index], rgb=rgb)
        
        # Try different OpenGL configurations, starting with the most advanced
        # and falling back to simpler ones if they fail (especially important on Windows)
        # This addresses the common "wglChoosePixelFormatARB is not exported" error on Windows
        # by providing multiple fallback options when advanced OpenGL features aren't available
        configs_to_try = []
        
        if sys.platform.startswith('win'):
            # On Windows, try multiple configurations due to driver compatibility issues
            # Try with multisampling first (if driver supports it)
            try:
                config_ms = Config(double_buffer=True)
                config_ms.sample_buffers = 1
                config_ms.samples = 4
                configs_to_try.append(config_ms)
            except Exception:
                pass  # Skip if Config creation fails
            
            # Fallback: basic double buffering without multisampling
            try:
                config_basic = Config(double_buffer=True)
                configs_to_try.append(config_basic)
            except Exception:
                pass  # Skip if Config creation fails
            
            # Fallback: single buffer
            try:
                config_single = Config(double_buffer=False)
                configs_to_try.append(config_single)
            except Exception:
                pass  # Skip if Config creation fails
            
            # Software rendering fallback - force minimal OpenGL requirements
            try:
                config_software = Config()
                config_software.double_buffer = False
                config_software.depth_size = 0
                config_software.stencil_size = 0
                config_software.aux_buffers = 0
                config_software.sample_buffers = 0
                config_software.samples = 0
                configs_to_try.append(config_software)
            except Exception:
                pass  # Skip if Config creation fails
            
            # Last resort: minimal configuration with no specific requirements
            try:
                config_minimal = Config()
                configs_to_try.append(config_minimal)
            except Exception:
                pass  # Skip if Config creation fails
                
            # Ultimate fallback: None (let pyglet choose defaults)
            configs_to_try.append(None)
        else:
            # On macOS/Linux, use the standard configuration
            config = Config(double_buffer=True)
            configs_to_try.append(config)
        
        # Try each configuration until one works
        window_created = False
        last_error = None
        
        for config in configs_to_try:
            try:
                if config is None:
                    # Let pyglet use default configuration
                    super(ClickerWindow, self).__init__(
                        width=int(float(self.frameFinder.ow) / factor),
                        height=int(float(self.frameFinder.oh) / factor),
                        visible=True,
                        resizable=True,
                        vsync=False)  # Disable vsync as fallback to avoid timing issues
                else:
                    super(ClickerWindow, self).__init__(
                        width=int(float(self.frameFinder.ow) / factor),
                        height=int(float(self.frameFinder.oh) / factor),
                        visible=True,
                        resizable=True,
                        vsync=True,
                        config=config)
                window_created = True
                print(f"Successfully created window with config: {config}")
                break
            except Exception as e:
                print(f"Failed to create window with config {config}: {e}")
                last_error = e
                # Check for the specific OpenGL error
                if "wglChoosePixelFormatARB" in str(e) or "ARB_pixel_format" in str(e):
                    print("Detected ARB_pixel_format issue, trying software rendering fallback...")
                    # Try to force software rendering
                    try:
                        import os
                        os.environ['LIBGL_ALWAYS_SOFTWARE'] = '1'
                        os.environ['GALLIUM_DRIVER'] = 'llvmpipe'
                    except Exception:
                        pass
                continue
        
        if not window_created:
            # If all configurations failed, try one final fallback without any config
            try:
                print("Trying final fallback: minimal window creation")
                super(ClickerWindow, self).__init__(
                    width=int(float(self.frameFinder.ow) / factor),
                    height=int(float(self.frameFinder.oh) / factor))
                window_created = True
                print("Successfully created window with minimal parameters")
            except Exception as final_error:
                print(f"Final fallback also failed: {final_error}")
                
                # Last resort: Try to force a different platform
                if sys.platform.startswith('win'):
                    try:
                        print("Trying platform override fallback...")
                        pyglet.options['gl_lib'] = None
                        pyglet.gl.gl_info.set_active_context()
                        super(ClickerWindow, self).__init__(
                            width=int(float(self.frameFinder.ow) / factor),
                            height=int(float(self.frameFinder.oh) / factor),
                            visible=False)  # Start invisible to avoid drawing issues
                        self.set_visible(True)
                        window_created = True
                        print("Successfully created window with platform override")
                    except Exception as platform_error:
                        print(f"Platform override also failed: {platform_error}")
                
                if not window_created:
                    # If all configurations failed, raise the last error with helpful message
                    error_msg = (f"Failed to create OpenGL window. This is usually due to outdated or incompatible "
                               f"graphics drivers on Windows. Original error: {last_error}\n\n"
                               f"Please try the following solutions:\n"
                               f"1. Update your graphics drivers (NVIDIA, AMD, or Intel)\n"
                               f"2. Install Mesa3D software renderer for Windows\n"
                               f"3. Run with software rendering: set MESA_GL_VERSION_OVERRIDE=3.3\n"
                               f"4. Check if your system supports OpenGL 2.0 or higher\n"
                               f"5. Try running as administrator")
                    raise Exception(error_msg) from last_error
               
        self.movie = movie
        self.offsets = offsets

        self.end = end
        self.points = {}
        self.current_point_index = 1
        self.displayingFrameNumber = True
        self.displayingDLTLines = False
        self.set_caption('{0} - Frame {1} - Track: {2}'.format(movie.split('/')[-1], 1, current_track_global))
        self.folder = ''
        self.current_marker = None
        self.scale_factor = factor
        # create array to keep track of offset changes
        self.offsets_output = np.zeros(self.end)
        self.offsets_output[:] = np.nan

        if self.actual_camera_number == 1:
            self.base = True
        else:
            self.base = False

        self.trackingColors = list()
        self.previous = list()
        self.autoTracking = False
        self.img = None
        # batches for fast drawing
        self.main_batch = pyglet.graphics.Batch()
        self.track_batch = pyglet.graphics.Batch()
        self.background = pyglet.graphics.Group(order=0)
        self.dlt_batch = pyglet.graphics.Batch()
        
        self.black_image = np.zeros((self.frameFinder.h, self.frameFinder.w, 3), dtype=np.uint8)
        
        # self.frame is array format from cv2, full size (or half depending on factor setting)
        self.frame = self.frameFinder.getFrame(1)
        # self.img is in pyglet image format to make it easier to get region.
        # self.img is full (or half) resolution, same as self.frame - scaling happens at draw
        if self.frame is not None:
            self.img = self.numpy_to_pyglet_image(self.frame, viewfinder = False)
        else:
            self.img = self.numpy_to_pyglet_image(self.black_image.copy(), viewfinder = False)
        # at init, frameFinder.w and h are full resolution, but self.frame.shape and self.image are resized based on scaling factor from main GUI

        
        if self.img is not None:
            self.img_sprite = pyglet.sprite.Sprite(self.img)
            # set image anchor to lower left (no panning yet)
            self.img_sprite.x = 0
            self.img_sprite.y = 0
        else:
            self.img_sprite = None

        # init current mouse coordinate for getting a zoomed view finder on init
        #self.x and y will change as soon as mouse moves
        self.x = 2 * vw
        self.y = 2 * vh

        # viewfinder zoom factor
        self.zoom_factor = 5
        self.viewfinder_zoomed_size = vw * self.zoom_factor
        self.view_sprite = None
        self.update_viewfinder()
        
        # modifiable boolean for showing the zoomed view finder
        self.show_view = False

        # dictionaries for storing OpenGL vertices and deleting later if needed
        self.drawn_points = {}
        self.drawn_lines = {}
        self.orig_dlt = []
        self.drawn_dlt = []

        # Initialize camera values
        self.left = 0
        self.right = self.frameFinder.ow
        self.bottom = 0
        self.top = self.frameFinder.oh
        self.zoom_level = 1
        self.zoomed_width = self.frameFinder.ow
        self.zoomed_height = self.frameFinder.oh

        self.update_tracks()

        self.changed = False

        self.vf = int(np.round(self.frameFinder.oh / (vw * 3.)))

    def safe_switch_to(self):
        """
        Safely switch to this window's OpenGL context.
        Returns True if successful, False otherwise.
        This helps prevent OpenGL context conflicts in multi-window scenarios on Windows.
        """
        global gl_context_lock
        if gl_context_lock:
            with gl_context_lock:
                try:
                    self.switch_to()
                    return True
                except Exception as e:
                    print(f"Failed to switch to context for {self.caption}: {e}")
                    return False
        else:
            try:
                self.switch_to()
                return True
            except Exception as e:
                print(f"Failed to switch to context for {self.caption}: {e}")
                return False

    def is_context_valid(self):
        """
        Check if the current OpenGL context is valid for this window.
        Returns True if valid, False otherwise.
        """
        try:
            # Try a simple OpenGL operation to verify context
            from pyglet import gl
            gl.glGetError()  # Clear any previous errors
            gl.glGetString(gl.GL_VERSION)  # Simple call to test context
            return True
        except Exception as e:
            print(f"Context validation failed for {self.caption}: {e}")
            return False

    def ensure_valid_context(self):
        """
        Ensure we have a valid OpenGL context before performing graphics operations.
        Returns True if context is valid and ready, False otherwise.
        """
        if not self.safe_switch_to():
            return False
        
        if not self.is_context_valid():
            print(f"Invalid OpenGL context for {self.caption}, attempting recovery...")
            try:
                # Try to recreate graphics batches if context is invalid
                self.track_batch = pyglet.graphics.Batch()
                self.dlt_batch = pyglet.graphics.Batch()
                self.main_batch = pyglet.graphics.Batch()
                return self.safe_switch_to()
            except Exception as e:
                print(f"Context recovery failed for {self.caption}: {e}")
                return False
        
        return True

    def clear_all_graphics_objects(self):
        """
        Clear all OpenGL graphics objects safely.
        This is used when recovering from context loss.
        """
        try:
            # Clear all drawn points
            for track in self.drawn_points:
                for i, point in enumerate(self.drawn_points[track]):
                    if point is not None:
                        try:
                            point.delete()
                        except Exception:
                            pass  # Ignore errors if object already deleted
                        self.drawn_points[track][i] = None
            
            # Clear all drawn lines
            for track in self.drawn_lines:
                for i, line in enumerate(self.drawn_lines[track]):
                    if line is not None:
                        try:
                            line.delete()
                        except Exception:
                            pass  # Ignore errors if object already deleted
                        self.drawn_lines[track][i] = None
            
            # Clear DLT lines
            for dlt_line in self.drawn_dlt:
                if dlt_line is not None:
                    try:
                        dlt_line.delete()
                    except Exception:
                        pass  # Ignore errors if object already deleted
            self.drawn_dlt = []
            
            # Clear current marker
            if self.current_marker is not None:
                try:
                    self.current_marker.delete()
                except Exception:
                    pass  # Ignore errors if object already deleted
                self.current_marker = None
                
            print(f"Cleared all graphics objects for {self.caption}")
        except Exception as e:
            print(f"Error clearing graphics objects for {self.caption}: {e}")

    def recreate_graphics_batches(self):
        """
        Recreate all graphics batches after context loss.
        """
        try:
            # Ensure valid context before recreating
            if not self.ensure_valid_context():
                return False
                
            # Clear existing objects first
            self.clear_all_graphics_objects()
            
            # Recreate batches
            self.main_batch = pyglet.graphics.Batch()
            self.track_batch = pyglet.graphics.Batch()
            self.dlt_batch = pyglet.graphics.Batch()
            
            # Redraw tracks if data exists
            if hasattr(self, 'points') and self.points:
                self.draw_tracks()
                
            print(f"Successfully recreated graphics batches for {self.caption}")
            return True
        except Exception as e:
            print(f"Failed to recreate graphics batches for {self.caption}: {e}")
            return False

    def safe_batch_draw(self, batch, batch_name="unknown"):
        """
        Safely draw a graphics batch with proper error handling and recovery.
        """
        global gl_context_lock
        try:
            if gl_context_lock:
                with gl_context_lock:
                    if not self.ensure_valid_context():
                        return False
                    batch.draw()
            else:
                if not self.ensure_valid_context():
                    return False
                batch.draw()
            return True
        except Exception as e:
            print(f"Failed to draw {batch_name} batch on {self.caption}: {e}")
            # Try to recover by clearing and rebuilding the specific batch
            try:
                if batch_name == "track":
                    print(f"Attempting to recover track batch for {self.caption}")
                    self.track_batch = pyglet.graphics.Batch()
                    self.rebuild_track_graphics()
                elif batch_name == "DLT":
                    print(f"Attempting to recover DLT batch for {self.caption}")
                    self.dlt_batch = pyglet.graphics.Batch()
                    if hasattr(self, 'get_epipolar_lines'):
                        self.get_epipolar_lines()
                return False  # Don't try to draw again this frame
            except Exception as recovery_error:
                print(f"Failed to recover {batch_name} batch for {self.caption}: {recovery_error}")
                return False

    def rebuild_track_graphics(self):
        """
        Rebuild track graphics safely with proper null checking.
        """
        try:
            if not self.ensure_valid_context():
                return False
                
            # Clear existing track graphics safely
            self.clear_track_graphics()
            
            # Rebuild current track
            self.draw_tracks_safe()
            
            # Rebuild current marker
            self.change_marker()
            
            print(f"Successfully rebuilt track graphics for {self.caption}")
            return True
        except Exception as e:
            print(f"Failed to rebuild track graphics for {self.caption}: {e}")
            return False

    def clear_track_graphics(self):
        """
        Clear track graphics objects safely, handling None values.
        """
        try:
            # Clear drawn points
            for track in self.drawn_points:
                for i, point in enumerate(self.drawn_points[track]):
                    if point is not None:
                        try:
                            point.delete()
                        except Exception:
                            pass
                        self.drawn_points[track][i] = None
            
            # Clear drawn lines
            for track in self.drawn_lines:
                for i, line in enumerate(self.drawn_lines[track]):
                    if line is not None:
                        try:
                            line.delete()
                        except Exception:
                            pass
                        self.drawn_lines[track][i] = None
            
            # Clear current marker
            if hasattr(self, 'current_marker') and self.current_marker is not None:
                try:
                    self.current_marker.delete()
                except Exception:
                    pass
                self.current_marker = None
                
        except Exception as e:
            print(f"Error clearing track graphics for {self.caption}: {e}")

    def draw_tracks_safe(self):
        """
        Draw tracks with comprehensive null checking and error handling.
        """
        global radius
        
        if not self.ensure_valid_context():
            return
        
        self.update_tracks()
        track = current_track_global
        
        # Guard against calling this before track data is loaded
        if track not in self.points:
            return
            
        try:
            positions = self.points[track]
            non_zeros = list(set(self.points[track].nonzero()[0]))

            # Clear existing graphics for this track to prevent mixing between windows
            if track in self.drawn_points:
                for i, point in enumerate(self.drawn_points[track]):
                    if point is not None:
                        try:
                            point.delete()
                        except Exception:
                            pass
                        self.drawn_points[track][i] = None
                        
            if track in self.drawn_lines:
                for i, line in enumerate(self.drawn_lines[track]):
                    if line is not None:
                        try:
                            line.delete()
                        except Exception:
                            pass
                        self.drawn_lines[track][i] = None

            # Draw all points for current track with null checking
            for non_zero_value in non_zeros:
                try:
                    pos = positions[non_zero_value].toarray()[0]
                    if self.is_valid_position(pos):
                        x, y = self.world_to_window(pos)
                        if x is not None and y is not None and not np.isnan(x) and not np.isnan(y):
                            self.drawn_points[track][non_zero_value] = draw_circle(
                                (x, y), radius,
                                color = colors[track_list_global.index(track) % len(colors)],
                                batch = self.track_batch
                            )
                except Exception as e:
                    print(f"Error drawing point {non_zero_value} for {track} on {self.caption}: {e}")

            # Draw lines connecting consecutive points with null checking
            for non_zero_value in non_zeros:
                if non_zero_value + 1 in non_zeros:
                    try:
                        pos1 = positions[non_zero_value].toarray()[0]
                        pos2 = positions[non_zero_value + 1].toarray()[0]
                        if self.is_valid_position(pos1) and self.is_valid_position(pos2):
                            x1, y1 = self.world_to_window(pos1)
                            x2, y2 = self.world_to_window(pos2)
                            if all(coord is not None and not np.isnan(coord) for coord in [x1, y1, x2, y2]):
                                self.drawn_lines[track][non_zero_value] = draw_line(
                                    (x1, y1), (x2, y2),
                                    color = colors[track_list_global.index(track) % len(colors)],
                                    batch = self.track_batch                        
                                )
                    except Exception as e:
                        print(f"Error drawing line from {non_zero_value} to {non_zero_value+1} for {track} on {self.caption}: {e}")

            # Draw all other tracks if displaying_all_tracks is enabled
            if displaying_all_tracks:
                for other_track in self.points.keys():
                    if other_track != current_track_global:
                        try:
                            other_positions = self.points[other_track]
                            other_non_zeros = list(set(self.points[other_track].nonzero()[0]))
                            
                            # Clear existing graphics for other tracks too
                            if other_track in self.drawn_points:
                                for i, point in enumerate(self.drawn_points[other_track]):
                                    if point is not None:
                                        try:
                                            point.delete()
                                        except Exception:
                                            pass
                                        self.drawn_points[other_track][i] = None
                                        
                            if other_track in self.drawn_lines:
                                for i, line in enumerate(self.drawn_lines[other_track]):
                                    if line is not None:
                                        try:
                                            line.delete()
                                        except Exception:
                                            pass
                                        self.drawn_lines[other_track][i] = None
                            
                            # Draw points for other tracks
                            for non_zero_value in other_non_zeros:
                                try:
                                    pos = other_positions[non_zero_value].toarray()[0]
                                    if self.is_valid_position(pos):
                                        x, y = self.world_to_window(pos)
                                        if x is not None and y is not None and not np.isnan(x) and not np.isnan(y):
                                            self.drawn_points[other_track][non_zero_value] = draw_circle(
                                                (x, y), radius,
                                                color = colors[track_list_global.index(other_track) % len(colors)],
                                                batch = self.track_batch
                                            )
                                except Exception as e:
                                    print(f"Error drawing point {non_zero_value} for {other_track} on {self.caption}: {e}")
                            
                            # Draw lines for other tracks
                            for non_zero_value in other_non_zeros:
                                if non_zero_value + 1 in other_non_zeros:
                                    try:
                                        pos1 = other_positions[non_zero_value].toarray()[0]
                                        pos2 = other_positions[non_zero_value + 1].toarray()[0]
                                        if self.is_valid_position(pos1) and self.is_valid_position(pos2):
                                            x1, y1 = self.world_to_window(pos1)
                                            x2, y2 = self.world_to_window(pos2)
                                            if all(coord is not None and not np.isnan(coord) for coord in [x1, y1, x2, y2]):
                                                self.drawn_lines[other_track][non_zero_value] = draw_line(
                                                    (x1, y1), (x2, y2),
                                                    color = colors[track_list_global.index(other_track) % len(colors)],
                                                    batch = self.track_batch                        
                                                )
                                    except Exception as e:
                                        print(f"Error drawing line from {non_zero_value} to {non_zero_value+1} for {other_track} on {self.caption}: {e}")
                        except Exception as e:
                            print(f"Error drawing track {other_track} on {self.caption}: {e}")
                            
        except Exception as e:
            print(f"Error in draw_tracks_safe for {self.caption}: {e}")

    def is_valid_position(self, pos):
        """
        Check if a position is valid for drawing.
        """
        try:
            return (pos is not None and 
                   len(pos) >= 2 and 
                   not np.any(np.isnan(pos)) and 
                   not np.any(pos == 0) and
                   np.all(np.isfinite(pos)))
        except Exception:
            return False

    # convert numpy array to pyglet image format
    def numpy_to_pyglet_image(self, frame, viewfinder=False):
        if frame is None:
            # Use black image if frame is None
            frame = self.black_image.copy()
        elif not hasattr(frame, 'shape'):
            # Handle case where a method reference was passed instead of array
            raise ValueError(f"Invalid frame type: {type(frame)}. Expected numpy array, got {frame}")
        
        try:
            height, width, channels = frame.shape
            img_data = frame.tobytes()
            return ImageData(width, height, 'RGB', img_data, pitch = width * 3)
        except (ValueError, AttributeError) as e:
            print(f"Error converting frame to pyglet image: {e}")
            print(f"Frame type: {type(frame)}, Frame shape: {getattr(frame, 'shape', 'No shape attribute')}")
            # Fallback to black image
            fallback_frame = self.black_image.copy()
            height, width, channels = fallback_frame.shape
            img_data = fallback_frame.tobytes()
            return ImageData(width, height, 'RGB', img_data, pitch = width * 3)
    
    # only called upon loading a CSV. Pretty slow to define tons of vertices.
    def draw_tracks(self):
        global radius
        # Ensure this window's OpenGL context is valid before creating graphics objects
        if not self.ensure_valid_context():
            return
        
        self.update_tracks()
        track = current_track_global
        
        # Guard against calling this before track data is loaded
        if track not in self.points:
            return
            
        positions = self.points[track]
        non_zeros = list(set(self.points[track].nonzero()[0]))

        if self.current_point_index - 1 in non_zeros:
            self.current_marker = draw_circle(
                positions[self.current_point_index - 1].toarray()[0],
                radius + 4,
                color = MARKER_COLOR,
                batch = self.track_batch
            )

        for non_zero_value in non_zeros:
            self.drawn_points[track][non_zero_value] = draw_circle(
                positions[non_zero_value].toarray()[0],
                radius,
                color = colors[track_list_global.index(track) % len(colors)],
                batch = self.track_batch
            )

        for non_zero_value in non_zeros:
            if non_zero_value + 1 in non_zeros:
                self.drawn_lines[track][non_zero_value] = draw_line(
                        positions[non_zero_value].toarray()[0],
                        positions[non_zero_value+1].toarray()[0],
                        color = colors[track_list_global.index(track) % len(colors)],
                        batch = self.track_batch                        
                        )

        if displaying_all_tracks:
            for track in self.points.keys():
                if track != current_track_global:
                    positions = self.points[track]
                    non_zeros = list(set(self.points[track].nonzero()[0]))
                    for non_zero_value in non_zeros:
                        if non_zero_value + 1 in non_zeros:
                            self.drawn_lines[track][non_zero_value] = draw_line(
                                    positions[non_zero_value].toarray()[0],
                                    positions[non_zero_value+1].toarray()[0],
                                    color = colors[track_list_global.index(track) % len(colors)],
                                    batch = self.track_batch                        
                                )
                            
    # called when the user decides to display all the tracks
    def draw_all_tracks(self):
        self.update_tracks()
        for track in self.points.keys():
            positions = self.points[track]
            nz = list(set(self.points[track].nonzero()[0]))

            if track != current_track_global:
                for k in nz:
                    if k + 1 in nz:
                        x1, y1 = self.world_to_window(positions[k].toarray()[0])
                        x2, y2 = self.world_to_window(positions[k+1].toarray()[0])
                        self.drawn_lines[track][k] = draw_line(
                                    (x1, y1),
                                    (x2, y2),
                                    color = colors[track_list_global.index(track) % len(colors)],
                                    batch = self.track_batch                        
                            )

        self.update_drawings()
        
    # called when the user decides not to display all the tracks
    def delete_all_tracks(self):
        for track in self.points.keys():
            if track != current_track_global:
                for k in range(len(self.drawn_points[track])):
                    if self.drawn_points[track][k] is not None:
                        self.drawn_points[track][k].delete()
                        self.drawn_points[track][k] = None

                for k in range(len(self.drawn_lines[track])):
                    if self.drawn_lines[track][k] is not None:
                        self.drawn_lines[track][k].delete()
                        self.drawn_lines[track][k] = None

    # called when the user changes tracks
    def change_track(self, old_track):
        #radius = 2
        global radius
        
        # Ensure we have a valid context for this window before changing tracks
        if not self.safe_switch_to():
            print(f"Failed to switch to context for {self.caption} during track change")
            return
            
        if not self.ensure_valid_context():
            print(f"Invalid context for {self.caption} during track change")
            return
        
        # Guard against calling this before track data is loaded
        if old_track not in self.points or current_track_global not in self.points:
            print(f"Track data not found for {self.caption}: old_track={old_track}, current_track={current_track_global}")
            return
            
        try:
            # remove the points from the old track
            for k in range(len(self.drawn_points[old_track])):
                if self.drawn_points[old_track][k] is not None:
                    self.drawn_points[old_track][k].delete()
                    self.drawn_points[old_track][k] = None

            # remove lines from old track if not being displayed
            if not displaying_all_tracks:
                for k in range(len(self.drawn_lines[old_track])):
                    if self.drawn_lines[old_track][k] is not None:
                        self.drawn_lines[old_track][k].delete()
                        self.drawn_lines[old_track][k] = None

            positions = self.points[current_track_global]
            nz = list(set(self.points[current_track_global].nonzero()[0]))

            if self.current_marker is not None:
                self.current_marker.delete()
                self.current_marker = None

            if self.current_point_index - 1 in nz:
                x, y = self.world_to_window(positions[self.current_point_index - 1].toarray()[0])
                self.current_marker = draw_circle(
                    (x, y), radius + 4, 
                    color = MARKER_COLOR,
                    batch = self.track_batch
                )
            
            # draw markers for new current track
            for k in nz:
                x, y = self.world_to_window(positions[k].toarray()[0])
                self.drawn_points[current_track_global][k] = draw_circle(
                    (x, y), radius, 
                    color = colors[track_list_global.index(current_track_global) % 4], 
                    batch = self.track_batch
                )
            
            # add line for new current track (not needed if displaying all tracks because it's already drawn)
            if not displaying_all_tracks:
                for k in nz:
                    if k + 1 in nz:
                        x1, y1 = self.world_to_window(positions[k].toarray()[0])
                        x2, y2 = self.world_to_window(positions[k+1].toarray()[0])
                        self.drawn_lines[current_track_global][k] = draw_line(
                            (x1, y1),
                            (x2, y2),
                            color = colors[track_list_global.index(current_track_global) % 4],
                            batch = self.track_batch                        
                            )
            
            # Mark for redraw and force graphics recovery to ensure everything is properly drawn
            self.changed = True
            
        except Exception as e:
            print(f"Error in change_track for {self.caption}: {e}")
            # If track change failed, try recovery
            self.recover_graphics_if_needed()

    def on_mouse_drag(self, x, y, dx, dy, buttons, modifiers):
        """Allows the user to drag around the current frame
        It's worth noting that in the BaseWindow class (a distant parent of this class) the function
        on_mouse_drag takes : x, y, dx, dy, buttons, modifiers as parameters with x oddly occupying the spot of
        self. However, in practice, all 6 parameters are passed, meaning that function signature simply can't be
        reimplemented.

        :param x: The current X value
        :param y: The current Y value
        :param dx: The distance the mouse was moved horizontally
        :param dy: The distance the mouse was moved vertically
        :param buttons: The buttons used in the drag
        :param modifiers: // TODO Better doc.
        :return: None
        """
        # Move camera
        if modifiers & key.MOD_SHIFT:
            left = self.left - dx #* self.zoom_level / self.scale_factor
            right = self.right - dx #* self.zoom_level / self.scale_factor
            bottom = self.bottom - dy #* self.zoom_level / self.scale_factor
            top = self.top - dy #* self.zoom_level / self.scale_factor

            self.left, self.right, self.bottom, self.top = left, right, bottom, top
            self.frameFinder.update(self.left, self.bottom, self.right - self.left, self.top - self.bottom)
            self.update_sprite()
            self.update_drawings()

    # converts from full resolution coordinates to window coordinates for drawing
    def world_to_window(self, pts):
        tx_x = (pts[0] / self.scale_factor * self.zoom_level) + self.img_sprite.x
        tx_y = (pts[1] / self.scale_factor * self.zoom_level) + self.img_sprite.y
        return tx_x, tx_y
    
    # converts from window coordinates to full resolution coordinates for saving data
    def window_to_world(self, pts):
        tx_x = (pts[0] - self.img_sprite.x) / self.zoom_level * self.scale_factor
        tx_y = (pts[1] - self.img_sprite.y) / self.zoom_level * self.scale_factor
        return tx_x, tx_y
    
    # update drawn circle and epipolar location for zoom and pan of window
    def update_drawings(self):
        global radius
        track = current_track_global
        new_point_index = self.current_point_index - 1
        old_point_index = self.current_point_index - 2
        
        # Guard against calling this before track data is loaded
        if track not in self.points:
            return
        
        # draw circles
        positions = self.points[track].toarray()
        #non_zero_points is a list of indices (frames) of posisions where digitized points can be found
        non_zero_points = list(set(self.points[track].nonzero()[0]))
        # print(positions[non_zero_points])
        # for i, (x, y) in zip(non_zero_points, positions):
        for k in non_zero_points:
            # print(x, y)
            tx_x, tx_y = self.world_to_window(positions[k])
            if track in self.drawn_points and self.drawn_points[track][k] is not None:
                try:
                    self.drawn_points[track][k].x = tx_x
                    self.drawn_points[track][k].y = tx_y
                except Exception as e:
                    print(f"Error updating point position for {self.caption}: {e}")
                    # Clear the point if we can't update it
                    try:
                        self.drawn_points[track][k].delete()
                    except Exception:
                        pass
                    self.drawn_points[track][k] = None

        #update current marker
        if new_point_index in non_zero_points:
            if self.current_marker is not None:
                try:
                    tx_x, tx_y = self.world_to_window(positions[new_point_index])
                    self.current_marker.x = tx_x
                    self.current_marker.y = tx_y
                except Exception as e:
                    print(f"Error updating marker position for {self.caption}: {e}")
                    # Clear the marker if we can't update it
                    try:
                        self.current_marker.delete()
                    except Exception:
                        pass
                    self.current_marker = None
        
                    
        for k in non_zero_points:
            if k + 1 in non_zero_points:
                if track in self.drawn_lines and self.drawn_lines[track][k] is not None:
                    try:
                        x1, y1 = self.world_to_window(positions[k])
                        x2, y2 = self.world_to_window(positions[k+1])
                        
                        self.drawn_lines[track][k].x = x1
                        self.drawn_lines[track][k].y = y1
                        self.drawn_lines[track][k].x2 = x2
                        self.drawn_lines[track][k].y2 = y2
                    except Exception as e:
                        print(f"Error updating line position for {self.caption}: {e}")
                        # Clear the line if we can't update it
                        try:
                            self.drawn_lines[track][k].delete()
                        except Exception:
                            pass
                        self.drawn_lines[track][k] = None
                    
        #update all track lines if needed
        if self.draw_all_tracks:
            for other_track in self.points.keys():
                if other_track != track:
                    positions = self.points[other_track].toarray()
                    nz = list(set(self.points[other_track].nonzero()[0]))
                    for k in nz:
                        if k + 1 in nz:
                            if self.drawn_lines[other_track][k] is not None:
                                x1, y1 = self.world_to_window(positions[k])
                                x2, y2 = self.world_to_window(positions[k+1])
                                self.drawn_lines[other_track][k].x = x1
                                self.drawn_lines[other_track][k].y = y1
                                self.drawn_lines[other_track][k].x2 = x2
                                self.drawn_lines[other_track][k].y2 = y2
                            
        #update dlt line drawings
        if DLTCoefficients is not None:
            self.dlt_batch = pyglet.graphics.Batch() #clear out existing
            self.get_epipolar_lines()
                
    # called to update epipolar lines on all windows when a new point is added
    def update_all_windows_epipolar(self):
        original_window = self
        for window in pyglet.app.windows:
            if isinstance(window, ClickerWindow) and window != self:
                # Only update windows that are on the same frame as this window
                if window.current_point_index == self.current_point_index:
                    print(f"updating epipolar lines on {window.caption}")
                    try:
                        if not window.safe_switch_to():
                            continue
                        # Clear existing epipolar lines and recalculate
                        window.dlt_batch = pyglet.graphics.Batch()
                        window.drawn_dlt = []
                        window.get_epipolar_lines()
                        # Mark window as changed instead of forcing immediate redraw
                        window.changed = True
                    except Exception as e:
                        print(f"Failed to update epipolar lines on {window.caption}: {e}")
        # Switch back to the original window
        try:
            if not original_window.safe_switch_to():
                print("Failed to switch back to original window")
        except Exception as e:
            print(f"Failed to switch back to original window: {e}")

    # draw a new point
    def draw_new_point(self, x, y):
        
        global radius
        track = current_track_global

        # Ensure this window's OpenGL context is valid before creating graphics objects
        # This is crucial for proper multi-window support on Windows
        if not self.ensure_valid_context():
            return

        new_point_index = self.current_point_index - 1
        old_point_index = self.current_point_index - 2

        self.points[current_track_global][new_point_index] = np.array([x, y])
        self.offsets_output[new_point_index] = self.offsets[self.original_index]

        # Get the numpy array from the sparse csc_matrix representing the coordinate plane
        # with the bottom left corner as the center
        positions = self.points[track].toarray()

        # Note the extra [0] at the end is because numpy returns ([], ) when nonzero is called
        non_zero_points = set(self.points[track].nonzero()[0])

        # If a point already exists in the new slot
        if self.drawn_points[track][new_point_index] is not None:
            self.drawn_points[track][new_point_index].delete()

        # correct for zoom and pan
        tx_x, tx_y = self.world_to_window((x , y))

        self.drawn_points[track][new_point_index] = draw_circle(
                (tx_x, tx_y), radius, 
                color = colors[track_list_global.index(track) % len(colors)], 
                batch = self.track_batch
            )

        if new_point_index >= 0:
            # Draws a line from the current point to the previous point
            if old_point_index in non_zero_points:
                x1, y1 = self.world_to_window(positions[old_point_index])
                x2, y2 = self.world_to_window(positions[new_point_index])
                
                if self.drawn_lines[track][old_point_index] is not None:
                    self.drawn_lines[track][old_point_index].delete()
                    
                self.drawn_lines[track][old_point_index] = draw_line(
                                                                (x1, y1),
                                                                (x2, y2),
                                                                color = colors[
                                                                             track_list_global.index(track) % len(
                                                                                 colors)
                                                                             ],
                                                                batch = self.track_batch)

            # Draws a line to points ahead of the current one
            if self.current_point_index in non_zero_points and positions[self.current_point_index][0] != 0:
        
                x1, y1 = self.world_to_window(positions[new_point_index])
                x2, y2 = self.world_to_window(positions[self.current_point_index])
                if self.drawn_lines[track][new_point_index] is not None:
                    self.drawn_lines[track][new_point_index].delete()
                self.drawn_lines[track][new_point_index] = draw_line(
                                                                (x1, y1),
                                                                (x2, y2),
                                                                color = colors[
                                                                             track_list_global.index(track) % len(
                                                                                 colors)
                                                                             ],
                                                                batch = self.track_batch)
        
        self.change_marker()
        
        # Update epipolar lines on all windows if DLT coefficients are available
        if DLTCoefficients is not None:
            self.update_all_windows_epipolar()

    def change_marker(self):
        #  updates current marker with highlight
        global radius
        self.update_tracks()
        track = current_track_global

        # Ensure this window's OpenGL context is active
        if not self.safe_switch_to():
            return

        # Guard against calling this before track data is loaded
        if track not in self.points:
            # Clear any existing marker when track doesn't exist
            if self.current_marker is not None:
                try:
                    self.current_marker.delete()
                except Exception:
                    pass  # Ignore errors if object already deleted
                self.current_marker = None
            return

        positions = self.points[track]
        non_zero_points = list(set(self.points[track].nonzero()[0]))

        if self.current_marker is not None:
            try:
                self.current_marker.delete()
            except Exception:
                pass  # Ignore errors if object already deleted
            self.current_marker = None

        if self.current_point_index - 1 in non_zero_points:
            try:
                x, y = self.world_to_window(positions[self.current_point_index - 1].toarray()[0])
                self.current_marker = draw_circle(
                    (x, y), radius + 4, 
                    color = MARKER_COLOR, 
                    batch = self.track_batch
                )
            except Exception as e:
                print(f"Error creating marker for {self.caption}: {e}")
                self.current_marker = None
        
        # On macOS, force a redraw to ensure the marker is visible
        if sys.platform == 'darwin':
            try:
                self.dispatch_events()
            except Exception as e:
                print(f"Error dispatching events for marker update on {self.caption}: {e}")
                
        self.changed = True

    def recover_graphics_if_needed(self):
        """
        Check for graphics corruption and recover if needed.
        Call this after track changes or frame changes that might result in missing data.
        """
        try:
            # Ensure we have a valid context for THIS window before doing anything
            if not self.safe_switch_to():
                print(f"Cannot switch to context for {self.caption}, skipping recovery")
                return
                
            if not self.ensure_valid_context():
                print(f"Invalid context for {self.caption}, attempting context recovery")
                if not self.recreate_graphics_batches():
                    print(f"Context recovery failed for {self.caption}")
                    return
            
            # Check if we have valid data for the current track at current frame
            track = current_track_global
            frame = current_frame
            
            needs_recovery = False
            
            # Check if track exists in our data
            if track not in self.points:
                print(f"Track {track} not found in data for {self.caption}, triggering recovery")
                needs_recovery = True
            else:
                # Check if current frame has data for this track and verify graphics exist
                try:
                    positions = self.points[track]
                    if frame - 1 < positions.shape[0]:  # frame is 1-indexed, positions is 0-indexed
                        # Check if we have any points for this track
                        non_zero_points = list(set(positions.nonzero()[0]))
                        if non_zero_points:
                            # Check if graphics objects exist for the points we should have
                            if track in self.drawn_points:
                                missing_graphics = 0
                                for point_idx in non_zero_points:
                                    if (point_idx >= len(self.drawn_points[track]) or 
                                        self.drawn_points[track][point_idx] is None):
                                        missing_graphics += 1
                                
                                if missing_graphics > 0:
                                    print(f"Missing {missing_graphics} graphics objects for track {track} in {self.caption}, triggering recovery")
                                    needs_recovery = True
                            else:
                                print(f"No graphics data for track {track} in {self.caption}, triggering recovery")
                                needs_recovery = True
                except Exception as e:
                    print(f"Error checking data for track {track} at frame {frame} in {self.caption}: {e}")
                    needs_recovery = True
                
            # Perform recovery if needed
            if needs_recovery:
                print(f"Performing graphics recovery for {self.caption}")
                # Clear all graphics first to prevent mixing between windows
                self.clear_track_graphics()
                
                # Recreate track data structures if needed
                self.update_tracks()
                
                # Redraw everything for this window only
                self.draw_tracks_safe()
                self.change_marker()
                
                # Mark for redraw
                self.changed = True
                print(f"Graphics recovery completed for {self.caption}")
                    
        except Exception as e:
            print(f"Error in recover_graphics_if_needed for {self.caption}: {e}")
            # Fallback: try a simple redraw using existing methods
            try:
                if self.safe_switch_to():
                    self.clear_track_graphics()
                    self.update_tracks()
                    self.draw_tracks_safe()
                    self.change_marker()
                    self.changed = True
                    print(f"Fallback recovery completed for {self.caption}")
            except Exception as fallback_error:
                print(f"Fallback recovery also failed for {self.caption}: {fallback_error}")

    # delete a point
    def delete_point(self):

        track = current_track_global

        # Guard against calling this before track data is loaded
        if track not in self.points:
            return

        last_added_index = self.current_point_index - 1
        second_most_recent_index = self.current_point_index - 2

        # Reset the current marker
        if self.current_marker is not None:
            try:
                self.current_marker.delete()
            except Exception:
                pass  # Ignore errors if object already deleted
            self.current_marker = None

        # Check if drawn_points dict exists for this track
        if track in self.drawn_points and last_added_index < len(self.drawn_points[track]):
            if self.drawn_points[track][last_added_index] is not None:
                try:
                    self.drawn_points[track][last_added_index].delete()
                except Exception:
                    pass  # Ignore errors if object already deleted
                self.drawn_points[track][last_added_index] = None
                
        # Check if drawn_lines dict exists for this track
        if track in self.drawn_lines:
            if (second_most_recent_index < len(self.drawn_lines[track]) and 
                self.drawn_lines[track][second_most_recent_index] is not None):
                try:
                    self.drawn_lines[track][second_most_recent_index].delete()
                except Exception:
                    pass  # Ignore errors if object already deleted
                self.drawn_lines[track][second_most_recent_index] = None
                
            if (last_added_index < len(self.drawn_lines[track]) and 
                self.drawn_lines[track][last_added_index] is not None):
                try:
                    self.drawn_lines[track][last_added_index].delete()
                except Exception:
                    pass  # Ignore errors if object already deleted
                self.drawn_lines[track][last_added_index] = None

    # uses Hedrick's function to get a slope and intercept for the Epipolar lines
    def get_epipolar_lines(self):
        global DLTCoefficients
        global dlt_filename
        global camera_profile
        global camera_filename

        self.update_tracks()
        coordinates = []
        tmp = []
        dlt_coeff_2 = DLTCoefficients[self.original_index]

        # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
        for window in pyglet.app.windows:
            if isinstance(window, ClickerWindow):
                if self is not window:
                    try:
                        coordinates.append([window.actual_camera_number,
                                            window.points[current_track_global][self.current_point_index - 1].toarray()[0]])
                    except Exception as e:
                        print(e)
        coordinates = sorted(coordinates)
        for coordinate in coordinates:
            # coordinate[1] is [0. 0.] if no point marked
            if np.any(coordinate[1] != 0):
                dlt_coeff_1 = DLTCoefficients[coordinate[0] - 1]
                x_cord = coordinate[1][0]
                y_cord = coordinate[1][1]
                # each coordinate is [n, [[x, y]]] the first value is the camera number
                # Thus the camera profile is indexing at the literal profile for this camera
                if camera_profile is not None:
                    try:
                        _ = undistort_pts(np.asarray([x_cord, y_cord]), camera_profile[coordinate[0] - 1])[0]
                        x_cord = _[0]
                        y_cord = _[1]
                    except np.linalg.LinAlgError as e:
                        QtWidgets.QMessageBox.warning(None,
                            "Error",
                            f"Numpy complained with the following message: \n{e}\n"
                            "This typically indicates a malformed camera profile or incorrect DLT Coefficients\n"
                            "To prevent future dialogs from appearing, DLT Coefficients are going to be set to null. "
                            "If you would like to re-enable this feature, check your profile and coefficents again and reload "
                            "them."
                        )
                        DLTCoefficients = None
                        dlt_filename = ""
                        camera_profile = None
                        camera_filename = ""

                slope, intercept = getDLTLine(x_cord, y_cord, dlt_coeff_1, dlt_coeff_2)
                if camera_profile is None:
                    tmp.append(np.asarray([0, intercept]))
                    tmp.append(np.asarray([self.frameFinder.ow, slope * self.frameFinder.ow + intercept]))
                else:
                    tmp = self.get_bezier_curve(slope, intercept, camera_profile[coordinate[0] - 1])
                self.make_dlt_batch(tmp)
                
    # doesn't really get a bezier curve, just draws lines in between 70 points on the distorted epipolar line
    def get_bezier_curve(self, m, b, prof):
        pts = list()
        for k in range(-10, 60):
            pts.append(np.asarray([self.frameFinder.ow * k / 49., m * (self.frameFinder.ow * k / 49.) + b]))

        ret = redistort_pts(np.asarray(pts), prof)
        ret = np.reshape(ret, (len(pts), 2))

        for k in range(len(ret)):
            ret[k] = ret[k]
        return list(ret)

    # fills the batch for epipolar lines, drawn in Carolina Blue. Go tar heels!
    def make_dlt_batch(self, points):
        for k in range(len(points) - 1):
            x1, y1 = self.world_to_window(points[k])
            x2, y2 = self.world_to_window(points[k+1])
            self.drawn_dlt.append(draw_line((x1, y1),
                    (x2, y2),
                    color = CAROLINA_BLUE,
                    width = 2,
                    batch = self.dlt_batch))
                
    # Zooms in using OpenGL.  Has bounds so that none of the screen ever has blank space
    def on_mouse_scroll(self, x, y, dx, dy):
        self.zoom_vid(x, y, dy)
        
    def zoom_vid(self, x, y, zm):
        # Get scale factor
        f = ZOOM_IN_FACTOR if zm > 0 else ZOOM_OUT_FACTOR if zm < 0 else 1
        # If zoom_level is in the proper range
        if 0.01 <= self.zoom_level * f < 10:
            # find the new x, y coordinates of the cursor pixel after zoom
            new_x = float(x) - (float(x) - self.img_sprite.x) * f
            new_y = float(y) - (float(y) - self.img_sprite.y) * f
            zoom_level = f * self.zoom_level
            # disp_width and height is the width in original pixels of the zoomed view
            old_disp_width = self.frameFinder.ow / self.zoom_level
            old_disp_height = self.frameFinder.oh / self.zoom_level

            new_disp_width = old_disp_width / f #when zooming in, this should get smaller
            new_disp_height = old_disp_height / f
            
            # zoomed_width and height is the new width in zoomed pixels of the full res 
            zoomed_width = self.frameFinder.ow * self.zoom_level
            zoomed_height = self.frameFinder.oh * self.zoom_level

            # the camera coordinates in full res reference (the view of zoomed_width and height)
            left = -1 * new_x * self.scale_factor
            right = left + new_disp_width
            bottom = -1 * new_y * self.scale_factor
            top = bottom + new_disp_height
            
            # save values to class
            self.left = left
            self.right = right
            self.bottom = bottom
            self.top = top 
            self.zoomed_width = zoomed_width
            self.zoomed_height = zoomed_height
            
            self.zoom_level = zoom_level
            
            #update frameFinder.x, y, w, h
            self.frameFinder.update(self.left, self.bottom, new_disp_width, new_disp_height)
            
            # draw it all
            self.update_sprite()
            self.update_drawings()
                
    # draws the image based 
    def update_sprite(self):
        self.img_sprite.update(
            scale = self.zoom_level,
            x = -1 * self.left / self.scale_factor,
            y = -1 * self.bottom / self.scale_factor
        )

    # makes sure all the dictionaries have the proper keys
    def update_tracks(self):
        for track in track_list_global:
            try:
                self.points[track]
            except KeyError:
                self.points[track] = csc_matrix((self.end, 2))

            try:
                # Checks if the track key exists
                self.drawn_points[track]
                self.drawn_lines[track]
            except KeyError:
                self.drawn_points[track] = list()
                self.drawn_lines[track] = list()
                for k in range(self.points[track].shape[0]):
                    self.drawn_points[track].append(None)
                for k in range(self.points[track].shape[0] - 1):
                    self.drawn_lines[track].append(None)

    #redraws after changing circle radius or line thickness
    def redraw_all(self, rad, thick):
        global radius
        global thickness
        # rad and thick are booleans stating if state changed
        # drawn_points and _lines are dicts - [track][index]
        if rad:
            for track, pts in self.drawn_points.items():
                for k in range(len(pts)):
                    if pts[k] is not None:
                        pts[k].radius = radius                    
        if thick:
            for track, pts in self.drawn_lines.items():
                for k in range(len(pts)):
                    if pts[k] is not None:
                        pts[k].width = thickness
            
        
    # called by each window upon saving.
    # Fills a common dictionary with its tracks which is then written to a CSV using pandas.
    def fill_common_dictionary(self):
        global common

        uvs = dict()
        for track in self.points.keys():
            uvs[track] = copy.copy(self.points[track]).toarray()
            uvs[track][uvs[track] == 0] = np.nan
            common[track + '_cam_' + str(self.actual_camera_number) + '_x'] = uvs[track][:, 0]
            common[track + '_cam_' + str(self.actual_camera_number) + '_y'] = uvs[track][:, 1]

    # called for each window after the common dictionary is filled.
    # probably a more intuitive way to grab parts rather than indexing them
    def load_points(self):
        global load_data_global
        # for each track, load in your points
        matching = True

        # sys.stdout.flush()
        for track in self.points.keys():
            # sys.stdout.flush()
            current_track_index = track_list_global.index(track)
            self.points[track] = load_data_global[:,
                                 2 * current_track_index * no_cameras_global + 2 * self.original_index:
                                 2 * current_track_index * no_cameras_global + 2 * self.original_index + 2]

            if self.points[track].shape[0] > self.end:
                matching = False
        self.clearBatch()
        # sys.stdout.flush()
        start_time = time.time()
        self.draw_tracks()
        self.update_drawings()
        return matching

    def update_viewfinder(self):
        try:
            view = self.frameFinder.getViewFinder(self.current_point_index, self.x, self.y, vw, vh, self.vf,
                                                    self.autoTracking)
            # add red cross hairs
            view[int(view.shape[0] / 2), :] = np.array([255., 0., 0.])
            view[:, int(view.shape[1] / 2)] = np.array([255., 0., 0.])
        except:
            view = None
        if view is not None:
            view = self.numpy_to_pyglet_image(view, viewfinder = True)

            scale = ((self.width * self.height) / (self.frameFinder.oh * self.frameFinder.ow)) ** 0.5
            self.view_sprite = pyglet.sprite.Sprite(view)
            self.view_sprite.scale = scale

        # self.switch_to()
    def on_mouse_enter(self, x, y):
        self.activate()
        
    def on_activate(self):
        self.safe_switch_to()
        
    def on_draw(self):
        """
        Main drawing method with proper OpenGL context locking for Windows.
        Delegates actual drawing to _perform_draw for better error handling.
        """
        global gl_context_lock
        
        if gl_context_lock:
            try:
                with gl_context_lock:
                    self._perform_draw()
            except Exception as e:
                print(f"OpenGL draw error on {self.caption}: {e}")
                # Try to recover by recreating graphics batches
                try:
                    self.recreate_graphics_batches()
                except Exception as recovery_error:
                    print(f"Failed to recover graphics on {self.caption}: {recovery_error}")
        else:
            # Non-Windows platforms or when lock is disabled
            try:
                self._perform_draw()
            except Exception as e:
                print(f"OpenGL draw error on {self.caption}: {e}")
                try:
                    self.recreate_graphics_batches()
                except Exception as recovery_error:
                    print(f"Failed to recover graphics on {self.caption}: {recovery_error}")
    
    def _perform_draw(self):
        """
        Performs the actual drawing operations.
        This method assumes the OpenGL context is already properly set and locked.
        """
        # Ensure this window's OpenGL context is valid before drawing
        if not self.ensure_valid_context():
            return
            
        self.clear()
                
        if self.current_point_index != current_frame and sync:
            self.current_point_index = current_frame

        if self.changed:
            im = self.frameFinder.getFrame(self.current_point_index)
            if im is not None:
                self.img = self.numpy_to_pyglet_image(im, viewfinder=False)
                
            else:
                self.img = self.numpy_to_pyglet_image(self.black_image.copy(), viewfinder=False)
                
            self.img_sprite = pyglet.sprite.Sprite(self.img)
            self.update_sprite()
            self.update_drawings()
                
        if self.img is not None:
            self.img_sprite.draw()
            
        # if DLT coefficients are present, draw epipolar lines in Carolina Blue
        if DLTCoefficients is not None:
            self.safe_batch_draw(self.dlt_batch, "DLT")
        
        # Draw track batch using safe method
        self.safe_batch_draw(self.track_batch, "track")
            
        if not busy:
            # if not self.base:
            self.set_caption(
                '{0} - Frame {1}, Offset: {2} - Track: {3}'.format(self.movie.split('/')[-1], self.current_point_index,
                                                                self.frameFinder.offset, current_track_global))
        else:
            self.set_caption('{0} - Working...'.format(self.movie.split('/')[-1]))

        # viewfinder
        if self.show_view:
            if self.x != 0 and self.y != 0:
                try: 
                    self.update_viewfinder()
                except Exception:
                    self.view_sprite = None
                if self.view_sprite is not None:
                    self.view_sprite.draw()
                
        self.changed = False
        

    def tick(self):
        global sync

        if sync:
            sync = False
        if self.autoTracking:
            uv = self.points[current_track_global][self.current_point_index - 2][0].toarray()[0]
            pts = self.points[current_track_global].toarray()

            if self.frameFinder.kf is None:
                nz = sorted(list(set(self.points[current_track_global].nonzero()[0])))
                ind = [self.current_point_index - 2]
                for k in range(20):
                    if self.current_point_index - (3 + k) in nz:
                        ind = [self.current_point_index - (3 + k)] + ind
                    else:
                        break
                if len(ind) >= 2:
                    self.frameFinder.makeKalman(pts[ind])
            if uv[0] != 0:
                try:
                    pos = self.frameFinder.CrossTrack(uv[0] - vx, (self.frameFinder.oh - uv[1]) - vy, 2 * vx, 2 * vy)
                    if self.frameFinder.kf is not None:
                        self.frameFinder.update_kalman(pos)
                except Exception as e:
                    print(e)
                    self.autoTracking = False
                    pyglet.clock.unschedule(up)
                    return
                if not True in np.isnan(pos):
                    self.draw_new_point(pos[0], pos[1])

                self.changed = True
                self.current_point_index += 1
                if sync:
                    self.update_all_windows()
                    # self.updateSelf()
            else:
                self.autoTracking = False
                pyglet.clock.unschedule(up)
                return

    # called to make sure everybody gets the changes made by one window
    def update_all_windows(self):
        original_window = self
        # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
        for window in pyglet.app.windows:
            if isinstance(window, ClickerWindow):
                if self is not window:
                    print(f"updating {window.caption}")
                    try:
                        if not window.safe_switch_to():
                            continue
                        # Sync the current point index to this window
                        window.current_point_index = self.current_point_index
                        window.update_tracks()
                        window.dispatch_events()
                        # Mark window as changed instead of forcing immediate redraw
                        window.changed = True
                        # Ensure marker is updated with proper context
                        window.change_marker()
                        # Force a graphics recovery check on macOS to ensure marker is properly displayed
                        if sys.platform == 'darwin':
                            window.recover_graphics_if_needed()
                    except Exception as e:
                        print(f"Failed to update window {window.caption}: {e}")
        # Switch back to the original window
        try:
            if not original_window.safe_switch_to():
                print("Failed to switch back to original window")
        except Exception as e:
            print(f"Failed to switch back to original window: {e}")

    def dense_to_sparse(self, arr):
        # create a sparse data file with rows and columns indexed by the natural numbers
        # as per MATLAB etiquette
        row = list()
        col = list()
        val = list()
        for k in range(len(arr)):
            for j in range(arr.shape[1]):
                if not np.isnan(arr[k, j]):
                    row.append(k + 1)
                    col.append(j + 1)
                    val.append(arr[k, j])

        out = np.zeros((len(row) + 1, 3))
        out[1:, 0] = np.array(row)
        out[1:, 1] = np.array(col)
        out[1:, 2] = np.array(val)
        out[0, 0] = len(arr)
        out[0, 1] = arr.shape[1]
        out[0, 2] = len(row)
        return out

    def check_overwrite_files(self, filename, is_sparse=True):
        """
        Check if any output files would be overwritten and ask user for confirmation.
        
        Args:
            filename (str): Base filename prefix
            is_sparse (bool): Whether this is for sparse or non-sparse save
            
        Returns:
            bool: True if user confirms overwrite or no files exist, False to cancel
        """
        import os
        
        # List of file suffixes that will be created
        file_suffixes = ['-offsets.csv']
        
        if is_sparse:
            file_suffixes.extend(['-xypts.tsv'])
            # Check for DLT-related files
            if hasattr(self, 'points') and DLTCoefficients is not None and camera_profile is not None:
                file_suffixes.extend(['-xyzpts.tsv', '-xyzres.tsv'])
                # Check for bootstrap files
                if bstrap:
                    file_suffixes.extend(['-xyz-cis.tsv', '-spline-weights.tsv', '-spline-error-tolerances.tsv'])
            else:
                file_suffixes.append('-xyzres.csv')
        else:
            file_suffixes.extend(['-xypts.csv'])
            # Check for DLT-related files
            if hasattr(self, 'points') and DLTCoefficients is not None and camera_profile is not None:
                file_suffixes.extend(['-xyzpts.csv', '-xyzres.csv'])
                # Check for bootstrap files
                if bstrap:
                    file_suffixes.extend(['-xyz-cis.csv', '-spline-weights.csv', '-spline-error-tolerances.csv'])
            else:
                file_suffixes.append('-xyzres.csv')
        
        # Check which files already exist
        existing_files = []
        for suffix in file_suffixes:
            file_path = filename + suffix
            if os.path.exists(file_path):
                existing_files.append(os.path.basename(file_path))
        
        # If no files exist, proceed without warning
        if not existing_files:
            return True
        
        # Show warning dialog for existing files
        app = QtWidgets.QApplication.instance()
        if app is None:
            app = QtWidgets.QApplication([])
        
        file_list = '\n'.join(existing_files)
        message = f"The following files already exist and will be overwritten:\n\n{file_list}\n\nDo you want to continue?"
        
        reply = QtWidgets.QMessageBox.question(
            None, 
            "Overwrite Files?", 
            message,
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.No  # Default to No for safety
        )
        
        return reply == QtWidgets.QMessageBox.Yes

    def save_sparse(self, save_as=True):
        global global_filename
        filename = ''
        if save_as or global_filename == '':
            app = QtWidgets.QApplication.instance()
            if app is None:
                app = QtWidgets.QApplication([])
            w = SaveFilePopup("Select location and enter prefix for sparse file", global_filename.split('/')[-1], 'All files (*.*)')
            if w.filename:
                filename = clean_filename_for_prefix(w.filename)
        else:
            filename = global_filename
        if filename == '':
            return
        if filename != '' and type(filename) == str:
            # Check for existing files and get user confirmation
            if not self.check_overwrite_files(filename, is_sparse=True):
                return  # User cancelled the operation
            global_filename = filename
            for window in pyglet.app.windows:
                if isinstance(window, ClickerWindow):
                    window.fill_common_dictionary()

            offsets_out = list()

            for window in pyglet.app.windows:
                if isinstance(window, ClickerWindow):
                    offsets_out.append(window.offsets_output)

            offsets_out = np.array(offsets_out).T

            # get the header
            cols = sorted(common.keys())
            # stack all the columns together
            _ = common[cols[0]]
            _ = np.reshape(_, (_.shape[0], 1))
            for k in range(1, len(cols)):
                _ = np.hstack((_, np.reshape(common[cols[k]], (_.shape[0], 1))))
            pts = _

            dataf = pandas.DataFrame(self.dense_to_sparse(pts), columns=['Row', 'Column', 'Entry'])
            dataf[['Row', 'Column']] = dataf[['Row', 'Column']].astype(np.uint32)
            dataf.iloc[0].apply(np.uint32)
            if DLTCoefficients is not None and camera_profile is not None:
                # make a data frame for the xyz coordinates for all tracks and all frames
                xyzss = list()
                for j in range(pts.shape[1] // (2 * len(camera_profile))):
                    xyzs = uv_to_xyz(pts[:, j * 2 * len(camera_profile):(j + 1) * 2 * len(camera_profile)],
                                     camera_profile, DLTCoefficients)
                    xyzss.append(xyzs)
                xyzss = np.asarray(xyzss)
                _ = xyzss[0]
                for k in range(1, len(xyzss)):
                    _ = np.hstack((_, xyzss[k]))

                dataf1 = pandas.DataFrame(self.dense_to_sparse(_), columns=['Row', 'Column', 'Entry'])
                dataf1[['Row', 'Column']] = dataf1[['Row', 'Column']].astype(np.uint32)
                dataf1.iloc[0].apply(np.uint32)

                # save offsets (always non-sparse)
                datafo = pandas.DataFrame(offsets_out, columns=['camera_{0}'.format(u) for u in range(1, len(
                    [u for u in pyglet.app.windows if type(u) != GhostWindow]) + 1)])
                datafo.to_csv(filename + '-offsets.csv', index=False, na_rep='NaN')

                # get reprojection errors for all 3d points and make a data frame for it
                repoErrs = get_repo_errors(_, pts, camera_profile, DLTCoefficients).T
                dataf2 = pandas.DataFrame(self.dense_to_sparse(repoErrs), columns=['Row', 'Column', 'Entry'])
                dataf2[['Row', 'Column']] = dataf2[['Row', 'Column']].astype(np.uint32)
                dataf2.iloc[0].apply(np.uint32)

                if bstrap:
                    CIs, weights, tols = bootstrapXYZs(pts, repoErrs, camera_profile, DLTCoefficients)
                    upper = _ + CIs
                    lower = _ - CIs

                    _ = np.zeros((upper.shape[0], upper.shape[1] * 2))
                    _[_ == 0] = np.nan
                    for k in range(int(upper.shape[1] / 3)):
                        _[:, 2 * k * 3:2 * (k + 1) * 3] = np.concatenate(
                            (lower[:, k * 3:(k + 1) * 3], upper[:, k * 3:(k + 1) * 3]), axis=1)
                    dataf3 = pandas.DataFrame(self.dense_to_sparse(_), columns=['Row', 'Column', 'Entry'])
                    dataf3[['Row', 'Column']] = dataf3[['Row', 'Column']].astype(np.uint32)
                    dataf3.iloc[0].apply(np.uint32)

                    dataf3.to_csv(filename + '-xyz-cis.tsv', index=False, na_rep='NaN', sep='\t')

                    pandas.DataFrame(self.dense_to_sparse(weights), columns=['Row', 'Column', 'Entry']).to_csv(
                        filename + '-spline-weights.tsv', index=False, na_rep='NaN', sep='\t')
                    # pickle.dump(tols, open('tols.p', 'w'))
                    pandas.DataFrame(self.dense_to_sparse(np.reshape(tols, (1, len(xyz_cols)))),
                                     columns=['Row', 'Column', 'Entry']).to_csv(
                        filename + '-spline-error-tolerances.tsv', index=False, na_rep='NaN', sep='\t')

                # write the data frames to CSV
                dataf1.to_csv(filename + '-xyzpts.tsv', index=False, na_rep='NaN', sep='\t')
                dataf2.to_csv(filename + '-xyzres.tsv', index=False, na_rep='NaN', sep='\t')
            else:
                # for matlab compatibility, make a residual file, even if we can't reproject
                _ = np.zeros((self.end, len(track_list_global)))
                _[:, :] = np.nan
                dataf2 = pandas.DataFrame(_, columns=sorted(track_list_global))
                dataf2.to_csv(filename + '-xyzres.csv', index=False, na_rep='NaN')
            dataf.to_csv(filename + '-xypts.tsv', index=False, na_rep='NaN', sep='\t')
            QtWidgets.QMessageBox.information(None,"Success", f'Write successful! TSVs successfully written to {filename}.')
        
            settings = {
                "sync": sync,
                "displaying_all_tracks": displaying_all_tracks,
                "current_track": current_track_global,
                "auto_advance": auto_advance,
                "global_filename": global_filename,
                "rgb": rgb,
                "output_sparse": outputSparse,
                "bstrap": bstrap,
                "init_track": track_list_global[0]
            }

            ClickerProject.create(proj_path=filename,
                                  video_paths=movies_global,
                                  points=f"{filename}-xypts.csv",
                                  resolution=self.scale_factor,
                                  last_frame=self.current_point_index,
                                  offsets=f"{filename}-offsets.csv",
                                  dlt_coefficents=dlt_filename if dlt_filename else None,
                                  camera_profile=camera_filename if camera_filename else None,
                                  settings=settings)

    def save_non_sparse(self, saveas=True):
        """Saves the current points in a non-sparse format, to csv, suitable for dense tracking data."""
        global global_filename
        filename = ''
        if saveas or global_filename == '':
            app = QtWidgets.QApplication.instance()
            if app is None:
                app = QtWidgets.QApplication([])
            w = SaveFilePopup("Select location and enter prefix for dense file", global_filename.split('/')[-1], 'All files (*.*)')
            if w.filename:
                filename = clean_filename_for_prefix(w.filename)
        else:
            filename = global_filename
        if filename == '':
            return
        if filename != '' and type(filename) == str:
            # Check for existing files and get user confirmation
            if not self.check_overwrite_files(filename, is_sparse=False):
                return  # User cancelled the operation
            global_filename = filename
            # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
            for window in pyglet.app.windows:
                if isinstance(window, ClickerWindow):
                    window.fill_common_dictionary()

            # get the header
            cols = sorted(common.keys())
            # stack all the columns together
            _ = common[cols[0]]
            _ = np.reshape(_, (_.shape[0], 1))
            for k in range(1, len(cols)):
                _ = np.hstack((_, np.reshape(common[cols[k]], (_.shape[0], 1))))
            # make a dataframe from the marked pixel coordinates
            dataf = pandas.DataFrame(_, columns=cols)
            pts = dataf.values

            offsets_out = list()

            # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
            for window in pyglet.app.windows:
                if isinstance(window, ClickerWindow):
                    offsets_out.append(window.offsets_output)

            offsets_out = np.array(offsets_out).T

            # save offsets (always non-sparse)
            datafo = pandas.DataFrame(offsets_out, columns=['camera_{0}'.format(u) for u in range(1, len(
                [u for u in pyglet.app.windows if type(u) != GhostWindow]) + 1)])
            datafo.to_csv(filename + '-offsets.csv', index=False, na_rep='NaN')

            # if we have DLT coefficients and intrinsic camera information, triangulate and write the 3D coordinates frame-by-frame
            if DLTCoefficients is not None and camera_profile is not None:
                # make a data frame for the xyz coordinates for all tracks and all frames
                xyzss = list()
                for j in range(int(pts.shape[1] / (2 * len(camera_profile)))):
                    xyzs = uv_to_xyz(pts[:, j * 2 * len(camera_profile):(j + 1) * 2 * len(camera_profile)],
                                     camera_profile, DLTCoefficients)
                    xyzss.append(xyzs)
                xyzss = np.asarray(xyzss)
                _ = xyzss[0]
                for k in range(1, len(xyzss)):
                    _ = np.hstack((_, xyzss[k]))

                xyz_cols = list()
                sTracks = sorted(track_list_global)
                for k in range(len(track_list_global)):
                    xyz_cols.append(sTracks[k] + '_x')
                    xyz_cols.append(sTracks[k] + '_y')
                    xyz_cols.append(sTracks[k] + '_z')
                dataf1 = pandas.DataFrame(_, columns=xyz_cols)

                # get reprojection errors for all 3d points and make a data frame for it
                repoErrs = get_repo_errors(_, pts, camera_profile, DLTCoefficients).T
                cols = sorted(track_list_global)
                dataf2 = pandas.DataFrame(repoErrs, columns=cols)

                if bstrap:
                    cols = list()
                    for k in range(len(track_list_global)):
                        cols.append(sTracks[k] + '_x_lower')
                        cols.append(sTracks[k] + '_y_lower')
                        cols.append(sTracks[k] + '_z_lower')
                        cols.append(sTracks[k] + '_x_upper')
                        cols.append(sTracks[k] + '_y_upper')
                        cols.append(sTracks[k] + '_z_upper')

                    CIs, weights, tols = bootstrapXYZs(pts, repoErrs, camera_profile, DLTCoefficients)
                    upper = dataf1.values + CIs
                    lower = dataf1.values - CIs

                    _ = np.zeros((upper.shape[0], upper.shape[1] * 2))
                    _[_ == 0] = np.nan
                    for k in range(int(upper.shape[1] / 3)):
                        _[:, 2 * k * 3:2 * (k + 1) * 3] = np.concatenate(
                            (lower[:, k * 3:(k + 1) * 3], upper[:, k * 3:(k + 1) * 3]), axis=1)
                    dataf3 = pandas.DataFrame(_, columns=cols)
                    dataf3.to_csv(filename + '-xyz-cis.csv', index=False, na_rep='NaN')

                    pandas.DataFrame(weights, columns=xyz_cols).to_csv(filename + '-spline-weights.csv', index=False,
                                                                       na_rep='NaN')

                    pandas.DataFrame(np.reshape(tols, (1, len(xyz_cols))), columns=xyz_cols).to_csv(
                        filename + '-spline-error-tolerances.csv', index=False, na_rep='NaN')

                # write the data frames to CSV
                dataf1.to_csv(filename + '-xyzpts.csv', index=False, na_rep='NaN')
                dataf2.to_csv(filename + '-xyzres.csv', index=False, na_rep='NaN')
            else:
                # for matlab compatibility, make a residual file, even if we can't reproject
                _ = np.zeros((self.end, len(track_list_global)))
                _[:, :] = np.nan
                dataf2 = pandas.DataFrame(_, columns=sorted(track_list_global))
                dataf2.to_csv(filename + '-xyzres.csv', index=False, na_rep='NaN')
            dataf.to_csv(filename + '-xypts.csv', index=False, na_rep='NaN')
            QtWidgets.QMessageBox.information(None, "Success", f'Write successful! CSVs successfully written to {filename}')

            settings = {
                "sync": sync,
                "displaying_all_tracks": displaying_all_tracks,
                "current_track": current_track_global,
                "auto_advance": auto_advance,
                "global_filename": global_filename,
                "rgb": rgb,
                "output_sparse": outputSparse,
                "bstrap": bstrap,
                "init_track": track_list_global[0]
            }

            ClickerProject.create(proj_path=filename,
                                  video_paths=movies_global,
                                  points=f"{filename}-xypts.csv",
                                  resolution=self.scale_factor,
                                  last_frame=self.current_point_index,
                                  offsets=f"{filename}-offsets.csv",
                                  dlt_coefficents=dlt_filename if dlt_filename else None,
                                  camera_profile=camera_filename if camera_filename else None,
                                  settings=settings)

    # pretty self explanatory
    def updateSelf(self):
        if not self.safe_switch_to():
            return
        self.update_tracks()
        self.dispatch_events()
        self.dispatch_event('on_draw')
        self.flip()

    def clearBatch(self):
        self.track_batch = pyglet.graphics.Batch()
        self.drawn_points = dict()
        self.drawn_lines = dict()
        self.orig_dlt = list()
        self.drawn_dlt = list()
        return

    # nests potentially long operations to let the user know that the program is working hard
    def toggleBusy(self):
        global busy

        if not busy:
            busy = True
        else:
            busy = False

        self.update_all_windows()
        self.updateSelf()

    def plotTracks(self):

        for window in pyglet.app.windows:
            if isinstance(window, ClickerWindow):
                window.fill_common_dictionary()
        cols = sorted(common.keys())
        _ = common[cols[0]]
        _ = np.reshape(_, (_.shape[0], 1))
        for k in range(1, len(cols)):
            _ = np.hstack((_, np.reshape(common[cols[k]], (_.shape[0], 1))))
        pts = _

        track_indices = np.arange(len(track_list_global))
        
        app = QtWidgets.QApplication.instance()
        running = True
        if app is None:
            running = False
            # necessary for regraphing after removing outliers using openGL
            QtWidgets.QApplication.setAttribute(Qt.AA_ShareOpenGLContexts)
            app = QtWidgets.QApplication(sys.argv)
            
        
        plotter = TrackPlotter(pts, track_indices, camera_profile, DLTCoefficients, ArgusColors)
        plotter.init_UI()
        plotter.show()
        app.exec()
        # if not running:
        #     app.exec()
        # pyglet.app.run()
        # fig = plt.figure()
        # ax = fig.add_subplot(111, projection='3d')
        # # make a data frame for the xyz coordinates for all tracks and all frames
        # xyzss = list()
        # for j in range(int(pts.shape[1] / (2 * len(camera_profile)))):
        #     xyzs = uv_to_xyz(pts[:, j * 2 * len(camera_profile):(j + 1) * 2 * len(camera_profile)], camera_profile,
        #                      DLTCoefficients)
        #     xyzss.append(xyzs)

        # colors = ArgusColors().getMatplotlibColors()

        # for k in range(len(track_indices)):
        #     xyz = xyzss[track_indices[k]]
        #     x = xyz[:, 0]
        #     y = xyz[:, 1]
        #     z = xyz[:, 2]
        #     ax.plot(x, y, z, color=colors[k % len(colors)])

        # plt.show(block=False)
        # plt.close()

    def deleteTrack(self, track):
        # delete the sparse array of points
        del self.points[track]

        # delete all drawn OpenGL vertices
        for k in range(len(self.drawn_points[track])):
            if self.drawn_points[track][k] is not None:
                self.drawn_points[track][k].delete()

        for k in range(len(self.drawn_lines[track])):
            if self.drawn_lines[track][k] is not None:
                self.drawn_lines[track][k].delete()

        # delete the dictionary keys and lists themselves
        del self.drawn_points[track]
        del self.drawn_lines[track]

    def options_menu(self):
        global sync
        global auto_advance
        global track_list_global
        global current_track_global
        global current_frame
        global load_data_global
        global displaying_all_tracks
        global busy
        global bstrap
        global outputSparse
        global rgb
        global vx
        global vy
        global radius
        global thickness

        self.toggleBusy()

        # make an options window and wait for it

        app = QtWidgets.QApplication.instance()
        if app is None:
            app = QtWidgets.QApplication([])
        w = OptionsPopupWindow(sync, auto_advance, track_list_global, current_track_global, displaying_all_tracks, bstrap, outputSparse, rgb, radius, thickness)
        if w.exec() == QtWidgets.QDialog.Accepted:
            auto_advance = w.auto.isChecked()
            sync = w.sync.isChecked()
            new_disp = w.disp.isChecked()
            bstrap = w.bstrap.isChecked()
            outputSparse = w.o_sparse
            rgb = w.rgb
            rad = False
            thick = False
            #radius changed, redraw all
            if radius != int(w.radius.text()):
                rad = True
                radius = int(w.radius.text())
            # line thickness changed, redraw all
            if thickness != int(w.thickness.text()):
                thick = True
                thickness = int(w.thickness.text())
            if rad or thick:
                self.redraw_all(rad, thick)

            track_list_global = w.track_list

            # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
            for window in pyglet.app.windows:
                if isinstance(window, ClickerWindow):
                    window.update_tracks()

            # if the current track changed and the displaying of the rest of the tracks did not
            if current_track_global != w.tracks.currentText() and new_disp == displaying_all_tracks:
                old_track = current_track_global
                current_track_global = w.tracks.currentText()
                # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
                for window in pyglet.app.windows:
                    if isinstance(window, ClickerWindow):
                        window.change_track(old_track)

            # if the current track changed and the displaying of other tracks was turned on
            elif current_track_global != w.tracks.currentText() and new_disp:
                # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
                for window in pyglet.app.windows:
                    if isinstance(window, ClickerWindow):
                        window.draw_all_tracks()
                old_track = current_track_global
                current_track_global = w.tracks.currentText()
                displaying_all_tracks = new_disp
                # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
                for window in pyglet.app.windows:
                    if isinstance(window, ClickerWindow):
                        window.change_track(old_track)

            # if the current track changed and the displaying of other tracks was turned off
            elif current_track_global != w.tracks.currentText():
                old_track = current_track_global
                current_track_global = w.tracks.currentText()
                # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
                for window in pyglet.app.windows:
                    if isinstance(window, ClickerWindow):
                        window.change_track(old_track)
                        window.delete_all_tracks()

            # if the track did not change but we turned on displaying the rest of
            # tracks
            elif new_disp != displaying_all_tracks and new_disp:
                # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
                for window in pyglet.app.windows:
                    if isinstance(window, ClickerWindow):
                        window.draw_all_tracks()

            # if the track did not change but we turned off the displaying of the rest of tracks
            elif new_disp != displaying_all_tracks and not new_disp:
                # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
                for window in pyglet.app.windows:
                    if isinstance(window, ClickerWindow):
                        window.delete_all_tracks()

            # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
            for window in pyglet.app.windows:
                if isinstance(window, ClickerWindow):
                    window.frameFinder.rgb = rgb
                    im = window.frameFinder.getFrame(window.current_point_index)
                    if im is None:
                        im = window.black_image.copy()
                        
                    window.img = pyglet.sprite.Sprite(window.numpy_to_pyglet_image(im))
                    window.img.scale = float(window.scale_factor)

            current_track_global = w.tracks.currentText()
            displaying_all_tracks = new_disp

        self.toggleBusy()
        self.update_drawings()
        self.update_all_windows()

    def go_to_frame(self, frame):
        global current_frame
        self.current_point_index = frame
        current_frame = self.current_point_index
        self.changed = True
        self.change_marker()

    def on_key_press(self, symbol, modifiers):
        """Manager for hotkeys
        :param symbol: Symbol passed from pyglt (?) representing the key pressed //Todo: Verify
        :param modifiers: // TODO: Document
        :return:
        """
        global sync
        global auto_advance
        global track_list_global
        global current_track_global
        global current_frame
        global load_data_global
        global displaying_all_tracks
        global busy
        global bstrap
        global outputSparse
        global rgb
        global vx
        global vy

        # brings up options dialog
        if symbol == key.O:
            self.options_menu()

        # turns on color-based contour autotracking
        elif symbol == key.A:
            self.frameFinder.destroy_kalman()
            self.frameFinder.track_image = None
            if self.autoTracking:
                self.autoTracking = False
                pyglet.clock.unschedule(up)
            else:
                if self.frameFinder.background_subtract:
                    self.frameFinder.toggleBackGroundSubtract()
                self.autoTracking = True
                pyglet.clock.schedule(up)
        elif symbol == key.V:
            if self.show_view:
                self.show_view = False
            else:
                self.show_view = True
            self.updateSelf()
        # skips one frame ahead
        elif symbol == key.F and (modifiers == 0 or modifiers == 16):
            if self.current_point_index + 1 <= self.end:
                self.changed = True
                self.current_point_index += 1
                current_frame = self.current_point_index
                self.change_marker()
                if sync:
                    self.update_all_windows()
        # skips 50 frames ahead
        elif symbol == key.F and modifiers & key.MOD_SHIFT:
            if self.current_point_index + 50 <= self.end:
                self.changed = True
                self.current_point_index += 50
                current_frame = self.current_point_index
                self.change_marker()
                if sync:
                    self.update_all_windows()
        # skips one frame behind
        elif symbol == key.B and (modifiers == 0 or modifiers == 16):
            if self.current_point_index - 1 > 0:
                self.changed = True
                self.current_point_index -= 1
                current_frame = self.current_point_index
                self.change_marker()
                if sync:
                    self.update_all_windows()
        # skips 50 frames back
        elif symbol == key.B and modifiers & key.MOD_SHIFT:
            if self.current_point_index - 50 > 0:
                self.changed = True
                self.current_point_index -= 50
                current_frame = self.current_point_index
                self.change_marker()
                if sync:
                    self.update_all_windows()
        # for capturing image
        elif symbol == key.C and modifiers & key.MOD_SHIFT:
            app = QtWidgets.QApplication.instance()
            if app is None:
                app = QtWidgets.QApplication([])
            w = SaveFilePopup("Select location to save captured image", global_filename.split('/')[-1], 'All files (*.*)')
            if w.filename:
                self.folder = w.filename
        elif symbol == key.C and modifiers & key.MOD_ALT:
            if self.folder != '':
                self.frameFinder.capture(self.folder)
            else:
                QtWidgets.QMessageBox.warning(None,
                    "Error",
                    "Must specify a directory before taking snapshots"
                )
                return
        # go to frame
        elif symbol == key.G:
            app = QtWidgets.QApplication.instance()
            if app is None:
                app = QtWidgets.QApplication([])
            w = GoToPopupWindow(self.end)
            if w.exec() == QtWidgets.QDialog.Accepted:
                try:
                    int(w.go_to_frame.value())
                except:
                    QtWidgets.QMessageBox.warning(None,
                        "Error",
                        "Frame to go to must be a valid integer"
                    )
                    return

            if 1 <= int(w.go_to_frame.value()) <= self.end:
                self.current_point_index = int(w.go_to_frame.value())
                current_frame = self.current_point_index
                self.changed = True
                self.change_marker()
                if sync:
                    self.update_all_windows()

            else:
                QtWidgets.QMessageBox.warning(None,
                    "Error",
                    "Frame out of bounds"
                )
        # changes track to the next one in the list
        elif symbol == key.PERIOD:
            start_time = time.time()

            old_track = current_track_global
            if track_list_global.index(current_track_global) + 1 < len(track_list_global):
                current_track_global = track_list_global[track_list_global.index(current_track_global) + 1]
            else:
                current_track_global = track_list_global[0]
            # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
            if current_track_global != old_track:
                for window in pyglet.app.windows:
                    if isinstance(window, ClickerWindow):
                        window.change_track(old_track)
                        # Force graphics recovery after track change
                        window.recover_graphics_if_needed()
                self.update_all_windows()

        # changes track to the previous one in the list
        elif symbol == key.COMMA:
            old_track = current_track_global
            if track_list_global.index(current_track_global) - 1 >= 0:
                current_track_global = track_list_global[track_list_global.index(current_track_global) - 1]
            else:
                current_track_global = track_list_global[-1]
            # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
            if current_track_global != old_track:
                for window in pyglet.app.windows:
                    if isinstance(window, ClickerWindow):
                        window.change_track(old_track)
                        # Force graphics recovery after track change
                        window.recover_graphics_if_needed()
                self.update_all_windows()
        # toggle the display of frame number in the current window
        elif symbol == key.F and modifiers & key.MOD_CTRL:
            if self.displayingFrameNumber:
                self.displayingFrameNumber = False
            else:
                self.displayingFrameNumber = True
                
        # Zoom with + - 
        elif symbol == key.EQUAL:
            self.zoom_vid(self._mouse_x, self._mouse_y, 1)
            
        elif symbol == key.MINUS:
            self.zoom_vid(self._mouse_x, self._mouse_y, -1)
        
        # reset to the original view of the entire frame
        elif symbol == key.R:
            win_ratio = self.width / self.height
            if (self.frameFinder.ow / self.frameFinder.oh) <= win_ratio:
                #narrower window than original aspect ratio
                self.zoom_level = self.width * self.scale_factor / self.frameFinder.ow
                self.left = 0
                self.bottom = 0
            else:
                #wider window
                self.zoom_level = self.height * self.scale_factor / self.frameFinder.oh
                
            self.left = 0
            self.bottom = 0
            self.right = self.left + self.width * self.scale_factor * self.zoom_level
            self.top = self.bottom + self.height * self.scale_factor * self.zoom_level
                
            self.zoomed_width = self.frameFinder.ow * self.zoom_level
            self.zoomed_height = self.frameFinder.oh * self.zoom_level
            self.frameFinder.update(self.left, self.bottom, self.right - self.left, self.top - self.bottom)
            self.update_sprite()
            self.update_drawings()
            
        # saving points to a CSV file
        elif symbol == key.S:
            if modifiers & key.MOD_CTRL:
                saveas = True
            else:
                saveas = False

            self.toggleBusy()
            if outputSparse:
                self.save_sparse(saveas)
            else:
                self.save_non_sparse(saveas)
            self.toggleBusy()
        elif symbol == key.X:
            self.toggleBusy()
            if sync:
                sync = False
            else:
                sync = True
            self.update_all_windows()
            self.toggleBusy()
        # skip to next marked point
        elif symbol == key.RIGHT:
            for k in range(self.current_point_index, self.points[current_track_global].shape[0]):
                if np.all(self.points[current_track_global][k].toarray()[0] != 0):
                    self.current_point_index = k + 1
                    current_frame = self.current_point_index
                    self.change_marker()
                    if sync:
                        self.update_all_windows()
                    self.changed = True
                    break
        # skip to previously marked point
        elif symbol == key.LEFT:
            for k in range(2, self.current_point_index):
                if np.all(self.points[current_track_global][self.current_point_index - k].toarray()[0] != 0):
                    self.current_point_index = self.current_point_index - k + 1
                    current_frame = self.current_point_index
                    self.change_marker()
                    if sync:
                        self.update_all_windows()
                    self.changed = True
                    break
        elif symbol == key.UP:
            # if not self.base:
            self.frameFinder.offset = self.frameFinder.offset + 1
            self.changed = True
            current_frame = self.current_point_index
            self.change_marker()
            if sync:
                self.update_all_windows()

        elif symbol == key.DOWN:
            # if not self.base:
            self.frameFinder.offset = self.frameFinder.offset - 1
            self.changed = True
            current_frame = self.current_point_index
            self.change_marker()
            if sync:
                self.update_all_windows()

        elif symbol == key.I:
            if vx - 1 >= 5:
                vx -= 1
        elif symbol == key.Y:
            if vx + 1 <= 30:
                vx += 1
        elif symbol == key.U:
            if vy - 1 >= 5:
                vy -= 1
        elif symbol == key._7:
            if vy + 1 <= 30:
                vy += 1

        # clearing all tracks from the current window
        elif symbol == key.C and (modifiers == 0 or modifiers == 16):
            app = QtWidgets.QApplication.instance()
            if app is None:
                app = QtWidgets.QApplication([])
            w = YesNoPopup(f"Clear all tracks for camera {self.actual_camera_number}. Are you sure?")
            if w.exec() == QtWidgets.QDialog.Accepted:
                if w.reply == 'Yes':
                    self.points = dict()
                    self.clearBatch()
                    self.update_tracks()
        elif symbol == key.D and modifiers & key.MOD_SHIFT:
            if len(track_list_global) > 1:
                app = QtWidgets.QApplication.instance()
                if app is None:
                    app = QtWidgets.QApplication([])
                w = YesNoPopup(f"Delete track {current_track_global}. Are you sure?")
                if w.exec() == QtWidgets.QDialog.Accepted:
                    if w.reply == 'Yes':
                        old_track = current_track_global
                        track_list_global.remove(current_track_global)
                        if len(track_list_global) != 0:
                            current_track_global = track_list_global[0]
                        # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
                        for window in pyglet.app.windows:
                            if isinstance(window, ClickerWindow):
                                window.change_track(old_track)
                                window.deleteTrack(old_track)
                        self.update_all_windows()
            else:
                QtWidgets.QMessageBox.warning(None,
                    "Error",
                    "Cannot delete track, must have at least one track to work with. Please add add a new track before deleting this one."
                )
            # self.trackingColors = list()
        # loading points from a CSV file
        elif symbol == key.L:
            self.toggleBusy()
            app = QtWidgets.QApplication.instance()
            if app is None:
                app = QtWidgets.QApplication([])
            w = OpenFilePopup(
                "Select _xypts.csv or _xypts.tsv",
                os.path.dirname(str(self.movie)),
                "CSV/TSV Files (*xypts.csv *xypts.tsv)"
            )
            if w.filename:
                filename = w.filename
                if type(filename) == str:
                    if filename != '' and filename.split('.')[-1] == 'csv':
                        load_csv(filename) #creates load_data_global as a csc_matrix for all points (shape of csv)

                    elif filename != '' and filename.split('.')[-1] == 'tsv':
                        outputSparse = True
                        load_tsv(filename)

            if load_data_global is not None:
                offsetMatches = list()
                # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
                for window in pyglet.app.windows:
                    if isinstance(window, ClickerWindow):
                        window.points = dict()
                        window.update_tracks() # gives points its track names as keys and each value as empty csc_matrix with shape of rows = frames and 2 cols
                        offsetMatches.append(window.load_points()) # assigns values to points from load_data_global
                        # on load, load_data_global is a csc_matrix, but the assignment uses normal indexing
                        window.updateSelf()
                if False in offsetMatches:
                    QtWidgets.QMessageBox.warning(None,
                        "Warning",
                        "Offsets may be wrong. There are more frames in the loaded CSV than there are in the first camera"
                    )

                load_data_global = None
            self.toggleBusy()
        # delete the point in the current frame and track
        elif symbol == key.D and (modifiers == 0 or modifiers == 16):
            positions = copy.copy(self.points[current_track_global])
            positions[self.current_point_index - 1] = np.asarray([0., 0.])
            positions.eliminate_zeros()
            self.points[current_track_global] = positions
            self.delete_point()
            
            # Update epipolar lines on all windows if DLT coefficients are available
            if DLTCoefficients is not None:
                self.update_all_windows_epipolar()
        # plot 3D tracks if we have dlt coefficients and camera profile
        elif symbol == key.P:
            self.toggleBusy()
            # if we have DLT coefficients and intrinsic camera information,
            # triangulate and write the 3D coordinates frame-by-frame
            if DLTCoefficients is not None and camera_profile is not None:
                self.plotTracks()
                # self.plotTracks(track_indices=np.arange(len(track_list_global)))
            else:
                QtWidgets.QMessageBox.warning(None,
                    "Error",
                    "Must have DLT coefficients and a camera profile to obtain 3D coordinates"
                )
            self.toggleBusy()
        elif symbol == key.P and modifiers & key.MOD_CTRL:
            self.toggleBusy()
            if DLTCoefficients is not None and camera_profile is not None:
                self.plotTracks(track_indices=[track_list_global.index(current_track_global)])
            else:
                QtWidgets.QMessageBox.warning(None,
                    "Error",
                    "Must have DLT coefficients and a camera profile to obtain 3D coordinates"
                )
            self.toggleBusy()

    def on_mouse_press(self, x, y, buttons, modifiers):
        global sync
        global auto_advance
        global track_list_global
        global current_track_global
        global current_frame
        
        # Ensure this window's OpenGL context is active
        if not self.safe_switch_to():
            return
        
        if buttons & mouse.LEFT:
            if current_track_global != '' and (modifiers == 16 or modifiers == 0):
                ptx, pty = self.window_to_world((float(x), float(y)))
                print(f"Drawing point at ({ptx:.2f}, {pty:.2f}) on camera {self.actual_camera_number}")
                self.draw_new_point(ptx, pty)
                if auto_advance:
                    im = self.frameFinder.getFrame(self.current_point_index + 1)
                    if im is not None and self.current_point_index + 1 <= self.end:
                        self.changed = True
                        self.current_point_index += 1
                        self.change_marker()
                        current_frame = self.current_point_index
                        if sync:
                            self.update_all_windows()
            elif modifiers & key.MOD_CTRL:
                self.trackingColors.append(self.frameFinder.getColor(np.asarray(
                    [float(x) / self.width * self.zoomed_width + self.left,
                     float(y) / self.height * self.zoomed_height + self.bottom])))

        elif buttons & mouse.RIGHT:
            positions = copy.copy(self.points[current_track_global])
            positions[self.current_point_index - 1] = np.asarray([0., 0.])
            positions.eliminate_zeros()
            self.points[current_track_global] = positions
            self.delete_point()
            
            # Update epipolar lines on all windows if DLT coefficients are available
            if DLTCoefficients is not None:
                self.update_all_windows_epipolar()

    def on_mouse_motion(self, x, y, dx, dy):
        if self.show_view and self.img is not None:
            self.x, self.y = self.window_to_world((x, y))

class TrackPlotter(QtWidgets.QWidget):
    def __init__(self, pts, track_indices, camera_profile, DLTcoefficients, ArgusColors):
        super().__init__()
        self.pts = pts
        self.track_indices = track_indices
        self.camera_profile = camera_profile
        self.DLTCoefficients = DLTCoefficients
        self.colors = ArgusColors().getPygletColors()
        self.xyzss = self.calculate_xyzs()
        
    def init_UI(self):
        import pyqtgraph.opengl as pyqt_gl  # Local import to avoid early OpenGL initialization
        main_layout = QtWidgets.QVBoxLayout()
        self.view = pyqt_gl.GLViewWidget()
        self.view.setWindowTitle('3D Graph')
        self.view.setCameraPosition(distance=20)
        # Create grid items for better visualization
        self.grid = pyqt_gl.GLGridItem()
        self.grid.scale(2, 2, 1)
        self.view.addItem(self.grid)
        # Add x, y, z axes lines
        axis_length = 10
        self.x_axis = pyqt_gl.GLLinePlotItem(pos=np.array([[0, 0, 0], [axis_length, 0, 0]]), color=(1, 0, 0, 1), width=2)  # Red line for x-axis
        self.y_axis = pyqt_gl.GLLinePlotItem(pos=np.array([[0, 0, 0], [0, axis_length, 0]]), color=(0, 1, 0, 1), width=2)  # Green line for y-axis
        self.z_axis = pyqt_gl.GLLinePlotItem(pos=np.array([[0, 0, 0], [0, 0, axis_length]]), color=(0, 0, 1, 1), width=2)  # Blue line for z-axis
        self.view.addItem(self.x_axis)
        self.view.addItem(self.y_axis)
        self.view.addItem(self.z_axis)
        main_layout.addWidget(self.view)
        self.setLayout(main_layout)
        self.resize(800, 800)
        self.updateGraph()
        
    def calculate_xyzs(self):
        xyzss = []
        for j in range(int(self.pts.shape[1] / (2 * len(self.camera_profile)))):
            xyzs = uv_to_xyz(self.pts[:, j * 2 * len(self.camera_profile):(j + 1) * 2 * len(self.camera_profile)], self.camera_profile, self.DLTCoefficients)
            xyzss.append(xyzs)
        return xyzss
        
    def updateGraph(self):
        import pyqtgraph.opengl as pyqt_gl  # Local import to avoid early OpenGL initialization
        self.view.clear()
        # Re-add grid and axes
        self.view.addItem(self.grid)
        self.view.addItem(self.x_axis)
        self.view.addItem(self.y_axis)
        self.view.addItem(self.z_axis)
        # plot here
        # Plot each track
        for k in range(len(self.track_indices)):
            xyz = self.xyzss[self.track_indices[k]]
            plotxyz = np.array(xyz).reshape(-1,3)
            color = self.colors[k % len(self.colors)]
            color = (color[0]/255.0, color[1]/255.0, color[2]/255.0, 1)
            
            scatter = pyqt_gl.GLScatterPlotItem(pos = plotxyz, color=color, size=20)
            
            scatter.setGLOptions('translucent')
            self.view.addItem(scatter)
        
# function scheduled everytime autotracking is turned on
# to create a loop. it is unscheduled when autotracking is turned off
def up(dt):
    # for window in [u for u in pyglet.app.windows if type(u) != GhostWindow]:
    for window in pyglet.app.windows:
        if isinstance(window, ClickerWindow):
            window.tick()
    # time.sleep(0.1)


# checks if there are other windows besides the Ghost Window
def check_to_close(dt):
    windows = [u for u in pyglet.app.windows]
    if len(windows) == 1:
        if type(windows[0]) == GhostWindow:
            windows[0].close()


# ghost window by Ty
class GhostWindow(pyglet.window.Window):
    def __init__(self):
        super(GhostWindow, self).__init__(width=10, height=10, visible=False, resizable=False)


def parse_csv(csv: str) -> lil_matrix:
    """Parses a csv file for a point matrix as formatted by argus
    :param csv: A path to a .csv file
    :return: a scipy lil_matrix with points like:
        [
            [cam1_x_track_1, cam1_y_track_1, cam2_x_track_1, cam2_y_track_1, ...., camN_x_track_1, camN_x_track_2]
            .
            .
            .
            [...]
        ]
        where each row represents a frame number corresponding to the original video
    """
    if csv.split('.')[-1] == 'csv':
        dataf = pandas.read_csv(csv, index_col=False)
        return dataf.values
    # else check if we have sparse data representation
    elif csv.split('.')[-1] == 'tsv':
        fo = open(csv)
        # expect a header
        line = fo.readline()
        # next line has shape information for the sparse matrix
        line = fo.readline()
        shape = list(map(int, line.split('\t')))
        # ret = lil_matrix((shape[0], shape[1]))
        ret = lil_matrix((shape[0], shape[1]))
        ret[:, :] = np.nan
        line = fo.readline()
        while line != '':
            val = list(map(float, line.split('\t')))
            ret[int(val[0]) - 1, int(val[1]) - 1] = val[2]
            line = fo.readline()
        return ret


def check_if_file(path):
    if path is None: return
    if not os.path.isfile(path):
        app = QtWidgets.QApplication.instance()
        if app is None:
            app = QtWidgets.QApplication([])
        QtWidgets.QMessageBox.warning(None,
            "Error",
            f"Unable to locate {path}"
        )
        return False

    else: return True


def load_settings(settings):
    global sync
    global displaying_all_tracks
    global current_track_global
    global auto_advance
    global global_filename
    global rgb
    global outputSparse
    global bstrap

    sync = settings["sync"]
    displaying_all_tracks = settings["displaying_all_tracks"]
    current_track_global = settings["current_track"]
    auto_advance = settings["auto_advance"]
    global_filename = settings["global_filename"]
    rgb = settings["rgb"]
    outputSparse = settings["output_sparse"]
    bstrap = settings["bstrap"]


def load_from_config(path):
    global movies_global
    global DLTCoefficients
    global dlt_filename

    try:
        with open(path, 'r', encoding='utf-8') as f:
            project = yaml.load(f, Loader=yaml.FullLoader)
    except yaml.YAMLError as e:
        print(f"Error loading YAML config file: {e}")
        return
    except Exception as e:
        print(f"Error reading config file: {e}")
        return

    if not project or not isinstance(project, list) or len(project) < 8:
        print("Invalid config file format. Expected a list with at least 8 elements.")
        return

    try:
        project_videos = project[0]
        project_points = project[1]
        if not check_if_file(project_points["points"]): 
            return

        project_resultion = project[2]
        project_last_frame = project[3]

        project_offsets = project[4]
        if not check_if_file(project_offsets["offsets"]): 
            return
            
        loaded_offsets = project_offsets["offsets"]
        frame_number = project_last_frame["last_frame"]
        loaded_res = project_resultion["resolution"]
        loaded_movies = project_videos["videos"]
        movies_global = loaded_movies

        loaded_offsets = parse_csv(loaded_offsets)
        useable_offsets = []

        dlt_coeff = project[5]
        dlt_path = dlt_coeff["dlt_coefficents"]
        if check_if_file(dlt_path):
            DLTCoefficients = np.loadtxt(dlt_path, delimiter=',')
            DLTCoefficients = DLTCoefficients.T
            dlt_filename = dlt_path

        camera_profile = project[6]
        camera_profile_path = camera_profile["camera_profile"]
        if check_if_file(camera_profile_path):
            load_camera(camera_profile_path)

        for camera_index in range(0, len(loaded_movies)):
            offset = loaded_offsets[frame_number - 2][camera_index]
            if np.isnan(offset):
                offset = 0
            useable_offsets.append(offset)

        loaded_end = int(cv2.VideoCapture(loaded_movies[0]).get(cv2.CAP_PROP_FRAME_COUNT))
    except (KeyError, IndexError, TypeError) as e:
        print(f"Error parsing config file structure: {e}")
        return
    except Exception as e:
        print(f"Error processing config file: {e}")
        return

    windows = []
    for index, movie in enumerate(loaded_movies):
        if not check_if_file(movie): return
        try:
            if index != len(loaded_movies) - 1:
                mov = ClickerWindow(movie, offsets=useable_offsets, actual_camera_number=index + 1, end=loaded_end,
                                  factor=loaded_res)
                mov.go_to_frame(frame_number)

                windows.append(mov)

            else:
                mov = ClickerWindow(movie, offsets=useable_offsets, actual_camera_number=index + 1, end=loaded_end,
                                             factor=loaded_res,
                                             last=True)
                mov.go_to_frame(frame_number)
                windows.append(mov)
        except Exception as e:
            print(f"\nERROR: Failed to create window for camera {index + 1} ({movie})")
            print(f"Error details: {e}")
            if sys.platform.startswith('win'):
                print("\nThis error is common on Windows systems with outdated or incompatible graphics drivers.")
                print("Suggested solutions:")
                print("1. Update your graphics drivers (NVIDIA, AMD, or Intel)")
                print("2. Try running with software rendering: set MESA_GL_VERSION_OVERRIDE=3.3")
                print("3. Install Mesa3D software renderer for Windows")
                print("4. Check if your system supports OpenGL 2.0 or higher")
            else:
                print("Please check your OpenGL drivers and system compatibility.")
            return

    load_csv(project_points["points"])
    
    settings = project[7]["settings"]
    load_settings(settings)
    
    if sys.platform == 'win32':
        pyglet.clock.schedule_once(check_to_close, .5)

    def update_after(_):
        indexable_windows = [u for u in windows if type(u) != GhostWindow]
        if load_data_global is not None:
            offsetMatches = list()
            for window in indexable_windows:
                # Ensure valid OpenGL context before modifying graphics data
                if not window.ensure_valid_context():
                    continue
                    
                window.points = dict()
                window.update_tracks()
                offsetMatches.append(window.load_points())
                # Force graphics recovery after loading points which creates new graphics objects
                window.recover_graphics_if_needed()
                window.updateSelf()

        # Safely change track and update all windows
        if indexable_windows and indexable_windows[0].safe_switch_to():
            indexable_windows[0].change_track(settings["init_track"])
            indexable_windows[0].update_all_windows()

        for window in indexable_windows:
            # Critical: Activate each window properly on Windows
            window.activate()
            if not window.safe_switch_to():
                continue
                
            # Ensure valid context before graphics operations
            if not window.ensure_valid_context():
                continue
                
            window.update_tracks()
            window.dispatch_events()
            window.dispatch_event('on_draw')
            window.flip()

            # Set RGB mode and update frame sprite with safe context
            window.frameFinder.rgb = rgb
            im = window.frameFinder.getFrame(window.current_point_index)
            if im is None:
                im = window.black_image.copy()
            
            # Ensure context is still valid before creating new sprite
            if window.ensure_valid_context():
                window.img = pyglet.sprite.Sprite(window.numpy_to_pyglet_image(im))
                window.img.scale = float(window.scale_factor)
                # Force graphics recovery after creating new sprite
                window.recover_graphics_if_needed()
                
    pyglet.clock.schedule_once(update_after, .05)
    pyglet.app.run()


if __name__ == '__main__':
    movies_global = None
    
    # Fix for Windows multi-window OpenGL context issues
    if sys.platform.startswith('win'):
        # Enable shared OpenGL contexts on Windows BEFORE creating QApplication
        QtWidgets.QApplication.setAttribute(Qt.AA_ShareOpenGLContexts)
        # Force single threaded OpenGL
        import os
        os.environ['PYGLET_SHADOW_WINDOW'] = '0'
        # Additional Windows OpenGL compatibility settings
        os.environ['PYGLET_GL_DISABLE_MULTISAMPLING'] = '1'  # Disable multisampling by default
        os.environ['PYGLET_GL_FALLBACK'] = '1'  # Enable fallback rendering
    
    # start a QT app for warning dialogs at least
    app = QtWidgets.QApplication.instance()
    if app is None:
        app = QtWidgets.QApplication([])
        
    if sys.argv[1].startswith("configload@"):
        config_path = sys.argv[1].split("@")[1]
        # Normalize the path for Windows compatibility
        config_path = os.path.normpath(config_path)
        load_from_config(config_path)

    else:
        end = int(sys.argv[2])
        movies_global = sys.argv[1].split('@')

        movies = movies_global
        offsets = list(map(int, sys.argv[3].split('@')))
        factor = int(sys.argv[4])

        windows = []
        for index, movie in enumerate(movies):
            try:
                if index != len(movies) - 1:
                    curWindow = ClickerWindow(movie, offsets=offsets, actual_camera_number=index + 1, end=end, factor=factor)
                    windows.append(curWindow)
                    if offsets[index] != 0 and offsets[index] < 0:
                        curWindow.go_to_frame(1 + np.abs(offsets[index]))
                else:
                    curWindow = ClickerWindow(movie, offsets=offsets, actual_camera_number=index + 1, end=end, factor=factor,
                                              last=True)

                    windows.append(curWindow)
                    if offsets[index] != 0 and offsets[index] < 0:       
                        curWindow.go_to_frame(1 + np.abs(offsets[index]))
            except Exception as e:
                print(f"\nERROR: Failed to create window for camera {index + 1} ({movie})")
                print(f"Error details: {e}")
                if sys.platform.startswith('win'):
                    print("\nThis error is common on Windows systems with outdated or incompatible graphics drivers.")
                    print("Suggested solutions:")
                    print("1. Update your graphics drivers (NVIDIA, AMD, or Intel)")
                    print("2. Try running with software rendering: set MESA_GL_VERSION_OVERRIDE=3.3")
                    print("3. Install Mesa3D software renderer for Windows")
                    print("4. Check if your system supports OpenGL 2.0 or higher")
                else:
                    print("Please check your OpenGL drivers and system compatibility.")
                sys.exit(1)

        if sys.platform == 'win32':
            pyglet.clock.schedule_once(check_to_close, .5)

        pyglet.app.run()
